{"version":3,"sources":["../../../../../apps/matte/src/app/api/matte/route.ts","../../../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../../../apps/matte/src/lib/matte/queries.ts","../../../../../apps/matte/src/lib/matte/intents.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { createClient, createAdminClient } from \"@drip/core/database/server\";\nimport { classifyIntent, detectEntities } from \"@/lib/matte/intents\";\nimport {\n  getUnpaidInvoices,\n  getOverdueInvoices,\n  getPaymentsThisWeek,\n  getJobsForDate,\n  getJobsInProgress,\n  getStuckJobs,\n  getMaterialsForDate,\n  getJobsMissingMaterials,\n  getFocusToday,\n  getGeneralSummary,\n  getJobsByNameOrCustomer,\n  getEstimatesForJob,\n  getMaterialsForJob,\n  getInvoicesForDateRange,\n  getCustomersWithUnpaidInvoices,\n  getJobsWithAcceptedEstimatesButNoInvoice,\n} from \"@/lib/matte/queries\";\n\n// System prompt for Matte\nconst SYSTEM_PROMPT = `ROLE\n\nYou are Matte AI, a read-only analytical assistant for a painting company.\n\nYour ONLY source of truth is the structured data explicitly provided to you in the context of the request.\n\nYou are not allowed to:\n- Guess\n- Infer missing values\n- Assume typical industry behavior\n- Fill gaps with \"common sense\"\n- Use external knowledge\n- Answer from memory\n\nIf the data is not present, you must say so.\n\nALLOWED DATA\n\nYou may ONLY answer questions using data from:\n- Jobs\n- Estimates\n- Invoices\n- Inventory items\n- Job materials checklists\n- Stores\n- Customers\n- Payments (if provided)\n- Company settings\n\nIf a field, record, or relationship is missing, you must treat it as unknown, not false.\n\nANSWER RULES (CRITICAL)\n\nRule 1 â€” No Data = No Answer\nIf the question cannot be answered exactly with the provided data:\nRespond with: \"I don't have enough data to answer that.\"\nOptionally add: \"Here's what I would need to answer it accurately: â€¦\"\n\nRule 2 â€” Cite the Source Internally\nEvery answer must state where the data came from.\nExample: \"Based on 12 completed jobs from Januaryâ€“March 2026â€¦\"\nIf you can't cite the source â†’ You cannot answer.\n\nRule 3 â€” Never Extrapolate\nDo NOT:\n- Project future totals\n- Average across incomplete datasets\n- Estimate missing consumption\n- Assume defaults unless explicitly provided\n\nBad âŒ: \"You probably used about 20 gallonsâ€¦\"\nGood âœ…: \"Recorded job materials show 14 gallons across 5 jobs.\"\n\nRule 4 â€” Ask to Clarify, Don't Guess\nIf the question is ambiguous, ask one clarifying question and stop.\nExample: \"Do you want only completed jobs, or all jobs including scheduled?\"\n\nRESPONSE FORMAT (MANDATORY)\n\nAll responses must follow this structure:\n\nðŸ“Š Answer\n(Short, direct answer or \"I don't have enough data.\")\n\nðŸ“ Data Used\n- Data source(s)\n- Date range\n- Filters applied\n\nâš ï¸ Limitations\n- What is missing or incomplete\n- Any assumptions explicitly NOT made\n\nHARD CONSTRAINTS (DO NOT VIOLATE)\n- NEVER answer with \"typically\", \"usually\", or \"most painters\"\n- NEVER invent quantities\n- NEVER use external knowledge\n- NEVER be confident without citations\n- NEVER hide uncertainty\n\nPRIMARY GOAL\nYour goal is trust, not completeness.\nA correct \"I don't know\" is always better than a wrong answer.\n\nFINAL CHECK (SELF-EVALUATION)\nBefore responding, silently verify:\n- Did I use only provided data?\n- Can I cite the source?\n- Did I avoid assumptions?\n- Did I clearly state limitations?\n\nIf any answer is \"no\" â†’ do not answer.`;\n\nexport async function POST(request: NextRequest) {\n  try {\n    const supabase = await createClient();\n    const adminSupabase = createAdminClient();\n\n    const {\n      data: { user },\n    } = await supabase.auth.getUser();\n\n    if (!user) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const { message } = await request.json();\n\n    if (!message || typeof message !== \"string\") {\n      return NextResponse.json({ error: \"Message required\" }, { status: 400 });\n    }\n\n    // Get company ID\n    const { data: companyUser } = await adminSupabase\n      .from(\"company_users\")\n      .select(\"company_id\")\n      .eq(\"user_id\", user.id)\n      .maybeSingle();\n\n    if (!companyUser) {\n      return NextResponse.json({ error: \"Company not found\" }, { status: 404 });\n    }\n\n    const companyId = companyUser.company_id;\n\n    // Classify intent\n    const intent = classifyIntent(message);\n\n    // Detect entities for flexible queries\n    const entities = detectEntities(message);\n\n    // Fetch data based on intent\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let data: any = {};\n    let userPrompt = \"\";\n    let specificRefusal = \"\";\n\n    switch (intent) {\n      case \"UNPAID_INVOICES\": {\n        const result = await getUnpaidInvoices(adminSupabase, companyId);\n        data = result;\n        const totalDollars = (result.total / 100).toFixed(2);\n        userPrompt = `The user asked about unpaid invoices. Here's the data:\n- Count: ${result.count}\n- Total: $${totalDollars}\n- Invoices: ${JSON.stringify(result.invoices.map((inv) => ({ customer: inv.customerName, amount: `$${(inv.amount / 100).toFixed(2)}` })))}\n\nRespond concisely about who hasn't paid.`;\n        break;\n      }\n\n      case \"OVERDUE_INVOICES\": {\n        const result = await getOverdueInvoices(adminSupabase, companyId);\n        data = result;\n        const totalDollars = (result.total / 100).toFixed(2);\n        userPrompt = `The user asked about overdue invoices. Here's the data:\n- Count: ${result.count}\n- Total: $${totalDollars}\n- Invoices: ${JSON.stringify(result.invoices.map((inv) => ({ customer: inv.customerName, amount: `$${(inv.amount / 100).toFixed(2)}` })))}\n\nRespond concisely about overdue invoices.`;\n        break;\n      }\n\n      case \"PAYMENTS_THIS_WEEK\": {\n        const result = await getPaymentsThisWeek(adminSupabase, companyId);\n        data = result;\n        const totalDollars = (result.total / 100).toFixed(2);\n        userPrompt = `The user asked about payments this week. Here's the data:\n- Count: ${result.count}\n- Total: $${totalDollars}\n- Payments: ${JSON.stringify(result.payments.map((p) => ({ customer: p.customerName, amount: `$${(p.amount / 100).toFixed(2)}` })))}\n\nRespond concisely about payments received this week.`;\n        break;\n      }\n\n      case \"JOBS_TODAY\": {\n        const today = new Date();\n        // Use local date to avoid timezone issues\n        const todayLocal = new Date(today.getFullYear(), today.getMonth(), today.getDate());\n        const result = await getJobsForDate(adminSupabase, companyId, todayLocal);\n        data = result;\n        \n        // Format today's date for the prompt\n        const todayStr = today.toLocaleDateString(\"en-US\", { weekday: \"long\", month: \"long\", day: \"numeric\", year: \"numeric\" });\n        \n        // Always log for debugging\n        console.log(\"JOBS_TODAY - Today date object:\", todayLocal);\n        console.log(\"JOBS_TODAY - Today date string:\", `${todayLocal.getFullYear()}-${String(todayLocal.getMonth() + 1).padStart(2, \"0\")}-${String(todayLocal.getDate()).padStart(2, \"0\")}`);\n        console.log(\"JOBS_TODAY - Result count:\", result.count);\n        console.log(\"JOBS_TODAY - Jobs found:\", result.jobs);\n        \n        userPrompt = `The user asked: \"${message}\"\n\nHere is the EXACT data available:\n- Date searched: ${todayStr}\n- Count: ${result.count}\n- Jobs: ${JSON.stringify(result.jobs.map((j) => ({ title: j.title, customer: j.customerName, status: j.status, scheduledDate: j.scheduledDate })))}\n\nCRITICAL: You must respond using ONLY this data. Use the mandatory format:\nðŸ“Š Answer\nðŸ“ Data Used\nâš ï¸ Limitations\n\nIf count is 0, your answer must be: \"I don't have enough data to answer that. No jobs are scheduled for today in the database.\"`;\n        break;\n      }\n\n      case \"JOBS_TOMORROW\": {\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        const result = await getJobsForDate(adminSupabase, companyId, tomorrow);\n        data = result;\n        userPrompt = `The user asked about jobs tomorrow. Here's the data:\n- Count: ${result.count}\n- Jobs: ${JSON.stringify(result.jobs.map((j) => ({ title: j.title, customer: j.customerName, status: j.status })))}\n\nRespond concisely about tomorrow's jobs.`;\n        break;\n      }\n\n      case \"JOBS_IN_PROGRESS\": {\n        const result = await getJobsInProgress(adminSupabase, companyId);\n        data = result;\n        userPrompt = `The user asked about jobs in progress. Here's the data:\n- Count: ${result.count}\n- Jobs: ${JSON.stringify(result.jobs.map((j) => ({ title: j.title, customer: j.customerName, status: j.status })))}\n\nRespond concisely about active jobs.`;\n        break;\n      }\n\n      case \"STUCK_JOBS\": {\n        const result = await getStuckJobs(adminSupabase, companyId);\n        data = result;\n        userPrompt = `The user asked about stuck jobs. Here's the data:\n- Count: ${result.count}\n- Jobs: ${JSON.stringify(result.jobs.map((j) => ({ title: j.title, customer: j.customerName, status: j.status })))}\n\nRespond concisely about jobs that haven't moved.`;\n        break;\n      }\n\n      case \"MATERIALS_TODAY\": {\n        const result = await getMaterialsForDate(adminSupabase, companyId, new Date());\n        data = result;\n        \n        if (result.materials.length === 0) {\n          userPrompt = `The user asked about materials needed for today. There are no materials needed for jobs scheduled today.\n\nRespond concisely: \"You don't need any materials for today.\"`;\n        } else {\n          userPrompt = `The user asked about materials needed for today. Here's the data:\n- Materials: ${JSON.stringify(result.materials.map((m) => ({ name: m.name, job: m.jobTitle, customer: m.customerName })))}\n\nRespond concisely about the materials needed. List the materials and which jobs they're for.`;\n        }\n        break;\n      }\n\n      case \"MATERIALS_TOMORROW\": {\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        const result = await getMaterialsForDate(adminSupabase, companyId, tomorrow);\n        data = result;\n        \n        if (result.materials.length === 0) {\n          userPrompt = `The user asked about materials needed for tomorrow. There are no materials needed for jobs scheduled tomorrow.\n\nRespond concisely: \"You don't need any materials for tomorrow.\"`;\n        } else {\n          userPrompt = `The user asked about materials needed for tomorrow. Here's the data:\n- Materials: ${JSON.stringify(result.materials.map((m) => ({ name: m.name, job: m.jobTitle, customer: m.customerName })))}\n\nRespond concisely about the materials needed tomorrow. List the materials and which jobs they're for.`;\n        }\n        break;\n      }\n\n      case \"JOBS_MISSING_MATERIALS\": {\n        const result = await getJobsMissingMaterials(adminSupabase, companyId);\n        data = result;\n        userPrompt = `The user asked about jobs missing materials. Here's the data:\n- Count: ${result.count}\n- Jobs: ${JSON.stringify(result.jobs.map((j) => ({ title: j.title, customer: j.customerName })))}\n\nRespond concisely about jobs that need materials added.`;\n        break;\n      }\n\n      case \"FOCUS_TODAY\": {\n        const result = await getFocusToday(adminSupabase, companyId);\n        data = result;\n        const unpaidTotalDollars = (result.unpaidTotal / 100).toFixed(2);\n        userPrompt = `The user asked what to focus on today. Here's the data:\n- Jobs today: ${result.jobsToday}\n- Unpaid invoices: ${result.unpaidInvoices}\n- Unpaid total: $${unpaidTotalDollars}\n\nRespond concisely about what to work on today.`;\n        break;\n      }\n\n      case \"GENERAL_SUMMARY\": {\n        const result = await getGeneralSummary(adminSupabase, companyId);\n        \n        // Also fetch recent jobs and invoices for context\n        const { data: recentJobs } = await adminSupabase\n          .from(\"jobs\")\n          .select(\"id, title, status, customer:customers(name)\")\n          .eq(\"company_id\", companyId)\n          .order(\"created_at\", { ascending: false })\n          .limit(20);\n\n        const { data: recentInvoices } = await adminSupabase\n          .from(\"invoices\")\n          .select(\"id, amount_total, status, created_at, customer:customers(name)\")\n          .eq(\"company_id\", companyId)\n          .order(\"created_at\", { ascending: false })\n          .limit(10);\n\n        const { data: customers } = await adminSupabase\n          .from(\"customers\")\n          .select(\"id, name\")\n          .eq(\"company_id\", companyId)\n          .order(\"name\")\n          .limit(50);\n\n        const generalData = result;\n        const invoicedDollars = (result.totalInvoiced / 100).toFixed(2);\n        const paidDollars = (result.totalPaid / 100).toFixed(2);\n        \n        const recentJobsList = (recentJobs || []).map((j: any) => ({\n          id: j.id,\n          title: j.title,\n          status: j.status,\n          customerName: j.customer?.name || \"Unknown\",\n        }));\n\n        const recentInvoicesList = (recentInvoices || []).map((inv: any) => ({\n          id: inv.id,\n          amount: inv.amount_total,\n          status: inv.status,\n          customerName: inv.customer?.name || \"Unknown\",\n          created: inv.created_at,\n        }));\n\n        data = { generalData, recentJobs: recentJobsList, recentInvoices: recentInvoicesList, customers };\n        userPrompt = `The user asked: \"${message}\"\n\nHere's what I know about the business:\n- Total jobs: ${generalData.totalJobs}\n- Active jobs: ${generalData.activeJobs}\n- Total invoiced: $${invoicedDollars}\n- Total paid: $${paidDollars}\n- Unpaid invoices: ${generalData.unpaidCount}\n\nRecent jobs (last 20):\n${JSON.stringify(recentJobsList)}\n\nRecent invoices (last 10):\n${JSON.stringify(recentInvoicesList)}\n\nCustomers:\n${JSON.stringify(customers?.map((c: any) => ({ name: c.name })) || [])}\n\nUse this data to answer the user's question. Be specific and helpful. If the question is about a specific job, customer, invoice, or material, provide details from the data above.`;\n        break;\n      }\n\n      case \"TOTAL_JOBS\": {\n        const result = await getGeneralSummary(adminSupabase, companyId);\n        data = result;\n        userPrompt = `The user asked about total jobs. Here's the data:\n- Total jobs: ${result.totalJobs}\n\nRespond concisely with the total number of jobs.`;\n        break;\n      }\n\n      case \"TOTAL_REVENUE\": {\n        const result = await getGeneralSummary(adminSupabase, companyId);\n        data = result;\n        const invoicedDollars = (result.totalInvoiced / 100).toFixed(2);\n        userPrompt = `The user asked about total revenue. Here's the data:\n- Total invoiced: $${invoicedDollars}\n\nRespond concisely with the total revenue/invoiced amount.`;\n        break;\n      }\n\n      case \"JOBS_THIS_WEEK\": {\n        // Calculate jobs this week\n        const weekAgo = new Date();\n        weekAgo.setDate(weekAgo.getDate() - 7);\n        const { data: jobs } = await adminSupabase\n          .from(\"jobs\")\n          .select(\"id, created_at\")\n          .eq(\"company_id\", companyId)\n          .gte(\"created_at\", weekAgo.toISOString());\n        const jobsThisWeek = jobs?.length || 0;\n        data = { count: jobsThisWeek };\n        userPrompt = `The user asked about jobs this week. Here's the data:\n- Jobs this week: ${jobsThisWeek}\n\nRespond concisely with how many jobs were created this week.`;\n        break;\n      }\n\n      case \"ACTIVE_JOBS\": {\n        const result = await getGeneralSummary(adminSupabase, companyId);\n        data = result;\n        userPrompt = `The user asked about active jobs. Here's the data:\n- Active jobs: ${result.activeJobs}\n\nRespond concisely with how many active jobs (scheduled or in progress) they have.`;\n        break;\n      }\n\n      case \"JOBS_BY_STATUS\": {\n        const { data: jobs } = await adminSupabase\n          .from(\"jobs\")\n          .select(\"status\")\n          .eq(\"company_id\", companyId);\n        const jobsByStatus = (jobs || []).reduce((acc, job) => {\n          acc[job.status] = (acc[job.status] || 0) + 1;\n          return acc;\n        }, {} as Record<string, number>);\n        data = { jobsByStatus };\n        userPrompt = `The user asked about jobs by status. Here's the data:\n${JSON.stringify(jobsByStatus)}\n\nRespond concisely with a breakdown of jobs by status.`;\n        break;\n      }\n\n      // New flexible intent handlers\n      case \"JOB_LOOKUP\":\n      case \"ESTIMATE_LOOKUP\":\n      case \"MATERIAL_LOOKUP\": {\n        if (!entities.jobIdentifier) {\n          specificRefusal = \"I need a job or customer name to look up that information.\";\n          break;\n        }\n\n        // Handle queries like \"my jobs\" or \"all jobs\" - fall back to general summary\n        const identifierLower = entities.jobIdentifier.toLowerCase();\n        if (identifierLower === 'my' || identifierLower === 'all' || identifierLower.includes('my ') || identifierLower.includes('all ')) {\n          // Fall back to general summary with jobs list\n          const result = await getGeneralSummary(adminSupabase, companyId);\n          const { data: recentJobs } = await adminSupabase\n            .from(\"jobs\")\n            .select(\"id, title, status, customer:customers(name)\")\n            .eq(\"company_id\", companyId)\n            .order(\"created_at\", { ascending: false })\n            .limit(20);\n          \n          data = { jobs: recentJobs || [] };\n          const jobsList = (recentJobs || []).map((j: any) => ({\n            title: j.title,\n            customer: j.customer?.name || \"Unknown\",\n            status: j.status,\n          }));\n          \n          userPrompt = `The user asked about their jobs. Here are their recent jobs:\n${JSON.stringify(jobsList)}\n\nRespond concisely about their jobs.`;\n          break;\n        }\n\n        // First, find the job(s)\n        const jobsResult = await getJobsByNameOrCustomer(adminSupabase, companyId, entities.jobIdentifier);\n\n        if (jobsResult.count === 0) {\n          specificRefusal = `I don't see any jobs matching \"${entities.jobIdentifier}\". Try asking about a specific customer name or job title.`;\n          break;\n        }\n\n        const job = jobsResult.jobs[0]; // Use first match\n\n        if (intent === \"ESTIMATE_LOOKUP\") {\n          const estimateResult = await getEstimatesForJob(adminSupabase, companyId, job.id);\n          if (estimateResult.count === 0) {\n            specificRefusal = `I don't see any estimates for the ${job.title} job.`;\n            break;\n          }\n          data = estimateResult;\n          const totalDollars = (estimateResult.total / 100).toFixed(2);\n          userPrompt = `The user asked about estimates for the \"${job.title}\" job (customer: ${job.customerName}). Here's the data:\n- Count: ${estimateResult.count}\n- Total: $${totalDollars}\n- Estimates: ${JSON.stringify(estimateResult.estimates.map((e) => ({\n  status: e.status,\n  total: `$${(e.total / 100).toFixed(2)}`,\n  lineItems: e.lineItems.slice(0, 3)\n})))}\n\nRespond concisely about the estimate amount and status.`;\n        } else if (intent === \"MATERIAL_LOOKUP\") {\n          const materialsResult = await getMaterialsForJob(adminSupabase, companyId, job.id);\n          if (materialsResult.materials.length === 0) {\n            specificRefusal = `I don't see any materials listed for the ${job.title} job.`;\n            break;\n          }\n          data = materialsResult;\n          userPrompt = `The user asked about materials/paint for the \"${job.title}\" job (customer: ${job.customerName}). Here's the data:\n- Materials: ${JSON.stringify(materialsResult.materials.map((m) => ({\n  name: m.name,\n  paintColor: m.paintColor,\n  sheen: m.sheen,\n  checked: m.checked\n})))}\n\nRespond concisely about what materials/paint are needed.`;\n        } else {\n          // JOB_LOOKUP\n          data = jobsResult;\n          userPrompt = `The user asked about jobs matching \"${entities.jobIdentifier}\". Here's the data:\n- Count: ${jobsResult.count}\n- Jobs: ${JSON.stringify(jobsResult.jobs.map((j) => ({\n  title: j.title,\n  customer: j.customerName,\n  status: j.status,\n  scheduledDate: j.scheduledDate\n})))}\n\nRespond concisely about the job(s) found.`;\n        }\n        break;\n      }\n\n      case \"INVOICE_LOOKUP\": {\n        let startDate: Date;\n        let endDate: Date;\n\n        if (entities.dateRange === \"last_month\") {\n          const now = new Date();\n          startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);\n          endDate = new Date(now.getFullYear(), now.getMonth(), 1);\n        } else if (entities.dateRange === \"this_week\") {\n          const now = new Date();\n          const dayOfWeek = now.getDay();\n          startDate = new Date(now);\n          startDate.setDate(now.getDate() - dayOfWeek);\n          endDate = new Date(now);\n          endDate.setDate(now.getDate() + (7 - dayOfWeek));\n        } else {\n          specificRefusal = \"I need a date range (like 'last month' or 'this week') to look up invoices.\";\n          break;\n        }\n\n        const invoiceResult = await getInvoicesForDateRange(adminSupabase, companyId, startDate, endDate);\n\n        if (invoiceResult.count === 0) {\n          specificRefusal = `I don't see any invoices in that date range.`;\n          break;\n        }\n\n        data = invoiceResult;\n        const totalDollars = (invoiceResult.total / 100).toFixed(2);\n        const dateRangeStr = entities.dateRange === \"last_month\" ? \"last month\" : \"this week\";\n        userPrompt = `The user asked about invoices for ${dateRangeStr}. Here's the data:\n- Count: ${invoiceResult.count}\n- Total: $${totalDollars}\n- Invoices: ${JSON.stringify(invoiceResult.invoices.map((inv) => ({\n  customer: inv.customerName,\n  job: inv.jobTitle,\n  amount: `$${(inv.amount / 100).toFixed(2)}`,\n  status: inv.status\n})))}\n\nRespond concisely about the invoices in that period.`;\n        break;\n      }\n\n      case \"CUSTOMER_LOOKUP\": {\n        const customerResult = await getCustomersWithUnpaidInvoices(adminSupabase, companyId);\n\n        if (customerResult.customers.length === 0) {\n          specificRefusal = \"All customers have paid their invoices!\";\n          break;\n        }\n\n        data = customerResult;\n        userPrompt = `The user asked about customers who owe money. Here's the data:\n- Customers: ${JSON.stringify(customerResult.customers.map((c) => ({\n  name: c.name,\n  unpaidCount: c.unpaidCount,\n  total: `$${(c.unpaidTotal / 100).toFixed(2)}`\n})))}\n\nRespond concisely about which customers have unpaid invoices.`;\n        break;\n      }\n\n      case \"RELATIONSHIP_QUERY\": {\n        if (entities.relationship === \"accepted_no_invoice\") {\n          const relationshipResult = await getJobsWithAcceptedEstimatesButNoInvoice(adminSupabase, companyId);\n\n          if (relationshipResult.count === 0) {\n            specificRefusal = \"All jobs with accepted estimates have been invoiced!\";\n            break;\n          }\n\n          data = relationshipResult;\n          userPrompt = `The user asked about jobs with accepted estimates but no invoice. Here's the data:\n- Count: ${relationshipResult.count}\n- Jobs: ${JSON.stringify(relationshipResult.jobs.map((j) => ({\n  title: j.title,\n  customer: j.customerName,\n  acceptedAt: j.acceptedAt\n})))}\n\nRespond concisely about which jobs need invoices created.`;\n        }\n        break;\n      }\n\n      case \"OUT_OF_SCOPE\": {\n        // Even if out of scope, if it mentions business terms, try to answer with available data\n        const normalized = message.toLowerCase();\n        if (/(job|material|invoice|customer|payment|estimate|paint|revenue|money|paid|unpaid)/i.test(normalized)) {\n          // Fall through to default case to fetch and answer with available data\n          // (intentionally no break)\n        } else {\n          return NextResponse.json({\n            response: \"I can only answer questions about your jobs, invoices, estimates, materials, and customers.\",\n          });\n        }\n      }\n\n      default: {\n        // Fallback: fetch comprehensive data for general questions\n        const [generalData, jobsData, invoicesData, customersData] = await Promise.all([\n          getGeneralSummary(adminSupabase, companyId),\n          adminSupabase\n            .from(\"jobs\")\n            .select(\"id, title, status, scheduled_date, scheduled_time, customer:customers(name)\")\n            .eq(\"company_id\", companyId)\n            .limit(20)\n            .order(\"created_at\", { ascending: false }),\n          adminSupabase\n            .from(\"invoices\")\n            .select(\"id, amount_total, status, created_at, customer:customers(name), job:jobs(title)\")\n            .eq(\"company_id\", companyId)\n            .limit(10)\n            .order(\"created_at\", { ascending: false }),\n          adminSupabase\n            .from(\"customers\")\n            .select(\"id, name, email, phone\")\n            .eq(\"company_id\", companyId)\n            .limit(10)\n            .order(\"name\")\n        ]);\n\n        const recentJobs = (jobsData.data || []).map(j => ({\n          title: j.title,\n          status: j.status,\n          customer: (j.customer as any)?.name || \"Unknown\",\n          scheduledDate: j.scheduled_date,\n          scheduledTime: j.scheduled_time\n        }));\n\n        const recentInvoices = (invoicesData.data || []).map(i => ({\n          customer: (i.customer as any)?.name || \"Unknown\",\n          job: (i.job as any)?.title || \"Unknown\",\n          amount: `$${(i.amount_total / 100).toFixed(2)}`,\n          status: i.status\n        }));\n\n        const customers = (customersData.data || []).map(c => ({\n          name: c.name,\n          email: c.email,\n          phone: c.phone\n        }));\n\n        // Also fetch materials for better context\n        // First get job IDs for this company\n        const { data: companyJobs } = await adminSupabase\n          .from(\"jobs\")\n          .select(\"id\")\n          .eq(\"company_id\", companyId);\n        \n        const jobIds = companyJobs?.map(j => j.id) || [];\n        \n        const { data: materialsData } = jobIds.length > 0 ? await adminSupabase\n          .from(\"job_materials\")\n          .select(\"name, notes, quantity_decimal, unit, job:jobs(title, customer:customers(name))\")\n          .in(\"job_id\", jobIds)\n          .limit(50) : { data: null };\n\n        const materials = (materialsData || []).map((m: any) => ({\n          name: m.name,\n          notes: m.notes,\n          quantity: m.quantity_decimal,\n          unit: m.unit,\n          jobTitle: m.job?.title || \"Unknown\",\n          customerName: m.job?.customer?.name || \"Unknown\",\n        }));\n\n        data = { generalData, recentJobs, recentInvoices, customers, materials };\n        userPrompt = `The user asked: \"${message}\"\n\nHere's what I know about the business:\n- Total jobs: ${generalData.totalJobs}\n- Active jobs: ${generalData.activeJobs}\n- Total invoiced: $${(generalData.totalInvoiced / 100).toFixed(2)}\n- Total paid: $${(generalData.totalPaid / 100).toFixed(2)}\n- Unpaid invoices: ${generalData.unpaidCount}\n\nRecent jobs (last 20):\n${JSON.stringify(recentJobs)}\n\nRecent invoices (last 10):\n${JSON.stringify(recentInvoices)}\n\nCustomers:\n${JSON.stringify(customers)}\n\nMaterials (last 50):\n${JSON.stringify(materials)}\n\nCRITICAL INSTRUCTIONS:\n1. You must respond using ONLY the data provided above\n2. Use the mandatory format:\n   ðŸ“Š Answer\n   ðŸ“ Data Used\n   âš ï¸ Limitations\n3. If you cannot answer with the provided data, say \"I don't have enough data to answer that.\"\n4. Always cite your sources (e.g., \"Based on jobs data\", \"From invoices data\")\n5. Never guess, infer, or assume anything not in the data\n6. If data is missing or incomplete, state it clearly in the Limitations section`;\n        break;\n      }\n    }\n\n    // Handle specific refusals first\n    if (specificRefusal) {\n      return NextResponse.json({\n        response: specificRefusal,\n      });\n    }\n\n    // Check if data is empty (skip check for metrics and date-based queries that should return 0)\n    const skipEmptyCheck = [\n      \"TOTAL_JOBS\",\n      \"TOTAL_REVENUE\",\n      \"JOBS_THIS_WEEK\",\n      \"ACTIVE_JOBS\",\n      \"JOBS_BY_STATUS\",\n      \"JOBS_TODAY\",\n      \"JOBS_TOMORROW\",\n      \"MATERIALS_TODAY\",\n      \"MATERIALS_TOMORROW\",\n      \"GENERAL_SUMMARY\"\n    ].includes(intent);\n    \n    // Don't refuse if we have general data (jobs, invoices, customers) even if specific query returned empty\n    const hasGeneralData = data.generalData || data.recentJobs || data.recentInvoices || data.customers || data.materials;\n    \n    if (\n      !skipEmptyCheck &&\n      !hasGeneralData &&\n      (\n        (data.count !== undefined && data.count === 0) ||\n        (data.jobs && data.jobs.length === 0) ||\n        (data.materials && data.materials.length === 0) ||\n        (data.payments && data.payments.length === 0)\n      )\n    ) {\n      return NextResponse.json({\n        response: \"I don't see any data for that right now.\",\n      });\n    }\n\n    // Call OpenAI API (using gpt-4o-mini for cost efficiency)\n    const openaiApiKey = process.env.OPENAI_API_KEY;\n    if (!openaiApiKey) {\n      // Fallback response if API key not configured\n      return NextResponse.json({\n        response: \"I can help answer questions about your jobs, invoices, and materials.\",\n      });\n    }\n\n    const openaiResponse = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${openaiApiKey}`,\n      },\n      body: JSON.stringify({\n        model: \"gpt-4o-mini\",\n        messages: [\n          { role: \"system\", content: SYSTEM_PROMPT },\n          { role: \"user\", content: userPrompt },\n        ],\n        max_tokens: 400,\n        temperature: 0.1,\n      }),\n    });\n\n    if (!openaiResponse.ok) {\n      console.error(\"OpenAI API error:\", await openaiResponse.text());\n      return NextResponse.json({\n        response: \"I'm having trouble right now. Please try again.\",\n      });\n    }\n\n    const openaiData = await openaiResponse.json();\n    const response = openaiData.choices[0]?.message?.content || \"I don't have an answer for that.\";\n\n    return NextResponse.json({ response });\n  } catch (error) {\n    console.error(\"Matte API error:\", error);\n    return NextResponse.json(\n      { response: \"I'm having trouble right now. Please try again.\" },\n      { status: 500 }\n    );\n  }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/matte/route\",\n        pathname: \"/api/matte\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/apps/matte/src/app/api/matte/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/matte/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","// Data aggregation queries for Matte\n// Each function returns only the data needed for responses\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { formatCurrency, formatDate } from \"@/lib/utils\";\n\ninterface UnpaidInvoicesData {\n  count: number;\n  total: number;\n  invoices: Array<{ id: string; customerName: string; amount: number; created: string }>;\n}\n\ninterface JobsData {\n  count: number;\n  jobs: Array<{ id: string; title: string; customerName: string; status: string; scheduledDate?: string; scheduledEndDate?: string }>;\n}\n\ninterface MaterialsData {\n  materials: Array<{\n    name: string;\n    jobTitle?: string;\n    customerName?: string;\n    paintColor?: string;\n    sheen?: string;\n    productLine?: string;\n    gallons?: number | null;\n    checked?: boolean;\n    notes?: string | null;\n  }>;\n}\n\ninterface PaymentsData {\n  count: number;\n  total: number;\n  payments: Array<{ amount: number; customerName: string; date: string }>;\n}\n\ninterface FocusData {\n  jobsToday: number;\n  unpaidInvoices: number;\n  unpaidTotal: number;\n}\n\nexport async function getUnpaidInvoices(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<UnpaidInvoicesData> {\n  const { data: invoices } = await supabase\n    .from(\"invoices\")\n    .select(\"id, amount_total, created_at, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .neq(\"status\", \"paid\")\n    .order(\"created_at\", { ascending: false });\n\n  const invoicesList = (invoices || []).map((inv) => ({\n    id: inv.id,\n    customerName: (inv.customer as any)?.name || \"Unknown\",\n    amount: inv.amount_total,\n    created: inv.created_at,\n  }));\n\n  const total = invoicesList.reduce((sum, inv) => sum + inv.amount, 0);\n\n  return {\n    count: invoicesList.length,\n    total,\n    invoices: invoicesList.slice(0, 10), // Limit to 10 for response\n  };\n}\n\nexport async function getOverdueInvoices(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<UnpaidInvoicesData> {\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n  const { data: invoices } = await supabase\n    .from(\"invoices\")\n    .select(\"id, amount_total, created_at, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .neq(\"status\", \"paid\")\n    .lt(\"created_at\", thirtyDaysAgo.toISOString())\n    .order(\"created_at\", { ascending: false });\n\n  const invoicesList = (invoices || []).map((inv) => ({\n    id: inv.id,\n    customerName: (inv.customer as any)?.name || \"Unknown\",\n    amount: inv.amount_total,\n    created: inv.created_at,\n  }));\n\n  const total = invoicesList.reduce((sum, inv) => sum + inv.amount, 0);\n\n  return {\n    count: invoicesList.length,\n    total,\n    invoices: invoicesList.slice(0, 10),\n  };\n}\n\nexport async function getPaymentsThisWeek(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<PaymentsData> {\n  const weekAgo = new Date();\n  weekAgo.setDate(weekAgo.getDate() - 7);\n\n  // Get invoices for company\n  const { data: companyInvoices } = await supabase\n    .from(\"invoices\")\n    .select(\"id\")\n    .eq(\"company_id\", companyId);\n\n  const invoiceIds = companyInvoices?.map((i) => i.id) || [];\n\n  if (invoiceIds.length === 0) {\n    return { count: 0, total: 0, payments: [] };\n  }\n\n  // Get payments for those invoices\n  const { data: payments } = await supabase\n    .from(\"invoice_payments\")\n    .select(\"amount, paid_at, invoice:invoices(customer:customers(name))\")\n    .in(\"invoice_id\", invoiceIds)\n    .gte(\"paid_at\", weekAgo.toISOString())\n    .order(\"paid_at\", { ascending: false });\n\n  const paymentsList = (payments || []).map((p) => ({\n    amount: p.amount,\n    customerName: (p.invoice as any)?.customer?.name || \"Unknown\",\n    date: p.paid_at,\n  }));\n\n  const total = paymentsList.reduce((sum, p) => sum + p.amount, 0);\n\n  return {\n    count: paymentsList.length,\n    total,\n    payments: paymentsList.slice(0, 10),\n  };\n}\n\nexport async function getJobsForDate(\n  supabase: SupabaseClient,\n  companyId: string,\n  date: Date\n): Promise<JobsData> {\n  // Normalize the target date to YYYY-MM-DD format\n  // Use UTC to avoid timezone issues - get the date components in local time but format as UTC date string\n  const targetYear = date.getFullYear();\n  const targetMonth = date.getMonth();\n  const targetDay = date.getDate();\n  \n  // Create a date string in YYYY-MM-DD format\n  const targetDateStr = `${targetYear}-${String(targetMonth + 1).padStart(2, \"0\")}-${String(targetDay).padStart(2, \"0\")}`;\n\n  // Fetch all jobs with scheduled dates for this company\n  const { data: allJobs, error } = await supabase\n    .from(\"jobs\")\n    .select(\"id, title, status, scheduled_date, scheduled_end_date, scheduled_time, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .not(\"scheduled_date\", \"is\", null);\n\n  if (error) {\n    console.error(\"Error fetching jobs for date:\", error, \"Target date:\", targetDateStr);\n    return { count: 0, jobs: [] };\n  }\n\n  // Filter jobs that overlap with the target date (handles multi-day jobs)\n  // A job overlaps if:\n  // - scheduled_date <= targetDate AND (scheduled_end_date >= targetDate OR scheduled_end_date IS NULL)\n  const matchingJobs = (allJobs || []).filter((job) => {\n    if (!job.scheduled_date) return false;\n    \n    // Extract date part - handle both formats\n    let jobStartDateStr: string;\n    if (job.scheduled_date.includes(\"T\")) {\n      jobStartDateStr = job.scheduled_date.split(\"T\")[0];\n    } else {\n      jobStartDateStr = job.scheduled_date;\n    }\n    \n    // If no end date, job is single-day - check if it matches target date\n    if (!job.scheduled_end_date) {\n      return jobStartDateStr.trim() === targetDateStr.trim();\n    }\n    \n    // Extract end date part\n    let jobEndDateStr: string;\n    if (job.scheduled_end_date.includes(\"T\")) {\n      jobEndDateStr = job.scheduled_end_date.split(\"T\")[0];\n    } else {\n      jobEndDateStr = job.scheduled_end_date;\n    }\n    \n    // Check if target date falls within the range [start, end] (inclusive)\n    const normalizedStart = jobStartDateStr.trim();\n    const normalizedEnd = jobEndDateStr.trim();\n    const normalizedTarget = targetDateStr.trim();\n    \n    return normalizedStart <= normalizedTarget && normalizedEnd >= normalizedTarget;\n  });\n\n  // Sort by scheduled_date then scheduled_time\n  matchingJobs.sort((a, b) => {\n    if (a.scheduled_date !== b.scheduled_date) {\n      return (a.scheduled_date || \"\").localeCompare(b.scheduled_date || \"\");\n    }\n    const timeA = a.scheduled_time || \"00:00\";\n    const timeB = b.scheduled_time || \"00:00\";\n    return timeA.localeCompare(timeB);\n  });\n\n  // Always log for debugging\n  console.log(\"getJobsForDate - Target date:\", targetDateStr);\n  console.log(\"getJobsForDate - All jobs with dates:\", allJobs?.length || 0);\n  console.log(\"getJobsForDate - Matching jobs:\", matchingJobs.length);\n  if (allJobs && allJobs.length > 0) {\n    console.log(\"getJobsForDate - All job scheduled dates:\", allJobs.map(j => ({\n      id: j.id,\n      title: j.title,\n      scheduled_date: j.scheduled_date,\n      datePart: j.scheduled_date?.split(\"T\")[0],\n      matches: j.scheduled_date?.split(\"T\")[0] === targetDateStr\n    })));\n  } else {\n    console.log(\"getJobsForDate - No jobs found with scheduled_date\");\n  }\n\n  const jobsList = matchingJobs.map((job) => ({\n    id: job.id,\n    title: job.title,\n    customerName: (job.customer as any)?.name || \"Unknown\",\n    status: job.status,\n    scheduledDate: job.scheduled_date,\n    scheduledEndDate: job.scheduled_end_date || undefined,\n  }));\n\n  return {\n    count: jobsList.length,\n    jobs: jobsList,\n  };\n}\n\nexport async function getJobsInProgress(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<JobsData> {\n  const { data: jobs } = await supabase\n    .from(\"jobs\")\n    .select(\"id, title, status, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .in(\"status\", [\"in_progress\", \"scheduled\"])\n    .order(\"updated_at\", { ascending: false });\n\n  const jobsList = (jobs || []).map((job) => ({\n    id: job.id,\n    title: job.title,\n    customerName: (job.customer as any)?.name || \"Unknown\",\n    status: job.status,\n  }));\n\n  return {\n    count: jobsList.length,\n    jobs: jobsList.slice(0, 10),\n  };\n}\n\nexport async function getStuckJobs(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<JobsData> {\n  const twoWeeksAgo = new Date();\n  twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);\n\n  const { data: jobs } = await supabase\n    .from(\"jobs\")\n    .select(\"id, title, status, updated_at, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .lt(\"updated_at\", twoWeeksAgo.toISOString())\n    .in(\"status\", [\"scheduled\", \"in_progress\", \"estimate_sent\"])\n    .order(\"updated_at\", { ascending: true });\n\n  const jobsList = (jobs || []).map((job) => ({\n    id: job.id,\n    title: job.title,\n    customerName: (job.customer as any)?.name || \"Unknown\",\n    status: job.status,\n  }));\n\n  return {\n    count: jobsList.length,\n    jobs: jobsList.slice(0, 10),\n  };\n}\n\nexport async function getMaterialsForDate(\n  supabase: SupabaseClient,\n  companyId: string,\n  date: Date\n): Promise<MaterialsData> {\n  const dateStr = date.toISOString().split(\"T\")[0];\n  const nextDay = new Date(date);\n  nextDay.setDate(nextDay.getDate() + 1);\n  const nextDayStr = nextDay.toISOString().split(\"T\")[0];\n\n  // Get jobs for date\n  const { data: jobs } = await supabase\n    .from(\"jobs\")\n    .select(\"id, title, scheduled_date, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .gte(\"scheduled_date\", dateStr)\n    .lt(\"scheduled_date\", nextDayStr);\n\n  if (!jobs || jobs.length === 0) {\n    return { materials: [] };\n  }\n\n  const jobIds = jobs.map((j) => j.id);\n\n  // Get materials for those jobs\n  const { data: materials } = await supabase\n    .from(\"job_materials\")\n    .select(\"name, job:jobs(title, customer:customers(name))\")\n    .in(\"job_id\", jobIds)\n    .eq(\"checked\", false);\n\n  const materialsList = (materials || []).map((m) => ({\n    name: m.name,\n    jobTitle: (m.job as any)?.title || \"Unknown\",\n    customerName: (m.job as any)?.customer?.name || \"Unknown\",\n  }));\n\n  return {\n    materials: materialsList.slice(0, 20),\n  };\n}\n\nexport async function getJobsMissingMaterials(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<JobsData> {\n  // Get active jobs\n  const { data: jobs } = await supabase\n    .from(\"jobs\")\n    .select(\"id, title, status, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .in(\"status\", [\"scheduled\", \"in_progress\"]);\n\n  if (!jobs || jobs.length === 0) {\n    return { count: 0, jobs: [] };\n  }\n\n  const jobIds = jobs.map((j) => j.id);\n\n  // Get jobs that have materials\n  const { data: materials } = await supabase\n    .from(\"job_materials\")\n    .select(\"job_id\")\n    .in(\"job_id\", jobIds);\n\n  const jobsWithMaterials = new Set((materials || []).map((m) => m.job_id));\n\n  // Find jobs without materials\n  const jobsWithoutMaterials = jobs\n    .filter((job) => !jobsWithMaterials.has(job.id))\n    .map((job) => ({\n      id: job.id,\n      title: job.title,\n      customerName: (job.customer as any)?.name || \"Unknown\",\n      status: job.status,\n    }));\n\n  return {\n    count: jobsWithoutMaterials.length,\n    jobs: jobsWithoutMaterials.slice(0, 10),\n  };\n}\n\nexport async function getFocusToday(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<FocusData> {\n  const today = new Date();\n  const jobsToday = await getJobsForDate(supabase, companyId, today);\n  const unpaid = await getUnpaidInvoices(supabase, companyId);\n\n  return {\n    jobsToday: jobsToday.count,\n    unpaidInvoices: unpaid.count,\n    unpaidTotal: unpaid.total,\n  };\n}\n\nexport async function getGeneralSummary(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<{\n  totalJobs: number;\n  activeJobs: number;\n  totalInvoiced: number;\n  totalPaid: number;\n  unpaidCount: number;\n}> {\n  const [jobs, invoices, unpaid] = await Promise.all([\n    supabase\n      .from(\"jobs\")\n      .select(\"id, status\")\n      .eq(\"company_id\", companyId),\n    supabase\n      .from(\"invoices\")\n      .select(\"id, amount_total, status\")\n      .eq(\"company_id\", companyId),\n    getUnpaidInvoices(supabase, companyId),\n  ]);\n\n  const jobsList = jobs.data || [];\n  const invoicesList = invoices.data || [];\n\n  const activeJobs = jobsList.filter((j) =>\n    [\"scheduled\", \"in_progress\"].includes(j.status)\n  ).length;\n\n  const totalInvoiced = invoicesList.reduce((sum, inv) => sum + inv.amount_total, 0);\n\n  // Get paid invoices\n  const paidInvoices = invoicesList.filter((inv) => inv.status === \"paid\");\n  const totalPaid = paidInvoices.reduce((sum, inv) => sum + inv.amount_total, 0);\n\n  return {\n    totalJobs: jobsList.length,\n    activeJobs,\n    totalInvoiced,\n    totalPaid,\n    unpaidCount: unpaid.count,\n  };\n}\n\n// New flexible query functions for entity-based queries\n\nexport async function getJobsByNameOrCustomer(\n  supabase: SupabaseClient,\n  companyId: string,\n  searchTerm: string\n): Promise<JobsData> {\n  // Clean up search term - remove common words\n  const cleanedTerm = searchTerm.toLowerCase().trim();\n  \n  // If search term is too generic, return empty\n  if (cleanedTerm === 'my' || cleanedTerm === 'all' || cleanedTerm.length < 2) {\n    return { count: 0, jobs: [] };\n  }\n  \n  // Search by job title or customer name (case-insensitive, partial match)\n  // Split search term into words and search for any word matching\n  const words = cleanedTerm.split(/\\s+/).filter(w => w.length > 1);\n  \n  let query = supabase\n    .from(\"jobs\")\n    .select(\"id, title, status, scheduled_date, customer:customers(name)\")\n    .eq(\"company_id\", companyId);\n  \n  // Build OR conditions for each word\n  if (words.length > 0) {\n    const conditions = words.map(word => \n      `title.ilike.%${word}%,customer.name.ilike.%${word}%`\n    ).join(',');\n    query = query.or(conditions);\n  } else {\n    query = query.or(`title.ilike.%${cleanedTerm}%,customer.name.ilike.%${cleanedTerm}%`);\n  }\n\n  const { data: jobs } = await query;\n\n  const jobsList = (jobs || []).map((job) => ({\n    id: job.id,\n    title: job.title,\n    customerName: (job.customer as any)?.name || \"Unknown\",\n    status: job.status,\n    scheduledDate: job.scheduled_date,\n  }));\n\n  return {\n    count: jobsList.length,\n    jobs: jobsList.slice(0, 10),\n  };\n}\n\ninterface EstimateData {\n  count: number;\n  total: number;\n  estimates: Array<{\n    id: string;\n    status: string;\n    sqft: number | null;\n    acceptedAt: string | null;\n    lineItems: Array<{ name: string; price: number; paintColor?: string; sheen?: string }>;\n    total: number;\n  }>;\n}\n\nexport async function getEstimatesForJob(\n  supabase: SupabaseClient,\n  companyId: string,\n  jobId: string\n): Promise<EstimateData> {\n  const { data: estimates } = await supabase\n    .from(\"estimates\")\n    .select(\"id, status, sqft, accepted_at, line_items:estimate_line_items(name, price, paint_color_name_or_code, sheen)\")\n    .eq(\"company_id\", companyId)\n    .eq(\"job_id\", jobId)\n    .order(\"created_at\", { ascending: false });\n\n  const estimatesList = (estimates || []).map((est) => {\n    const lineItems = (est.line_items as any[]) || [];\n    const total = lineItems.reduce((sum, item) => sum + (item.price || 0), 0);\n\n    return {\n      id: est.id,\n      status: est.status,\n      sqft: est.sqft,\n      acceptedAt: est.accepted_at,\n      lineItems: lineItems.slice(0, 10).map((item) => ({\n        name: item.name,\n        price: item.price,\n        paintColor: item.paint_color_name_or_code,\n        sheen: item.sheen,\n      })),\n      total,\n    };\n  });\n\n  const total = estimatesList.reduce((sum, est) => sum + (est.total || 0), 0);\n\n  return {\n    count: estimatesList.length,\n    total,\n    estimates: estimatesList as any,\n  };\n}\n\nexport async function getMaterialsForJob(\n  supabase: SupabaseClient,\n  companyId: string,\n  jobId: string\n): Promise<MaterialsData> {\n  // Get materials from job_materials table\n  const { data: jobMaterials } = await supabase\n    .from(\"job_materials\")\n    .select(\"name, checked, notes, job:jobs(title, customer:customers(name))\")\n    .eq(\"job_id\", jobId);\n\n  // Also get paint info from estimates if available\n  const { data: estimates } = await supabase\n    .from(\"estimates\")\n    .select(\"line_items:estimate_line_items(name, paint_color_name_or_code, sheen, product_line, gallons_estimate)\")\n    .eq(\"company_id\", companyId)\n    .eq(\"job_id\", jobId)\n    .eq(\"status\", \"accepted\");\n\n  const materials: any[] = [];\n\n  // Add job materials\n  if (jobMaterials && jobMaterials.length > 0) {\n    const job = (jobMaterials[0].job as any);\n    materials.push(...jobMaterials.map((m) => ({\n      name: m.name,\n      jobTitle: job?.title || \"Unknown\",\n      customerName: job?.customer?.name || \"Unknown\",\n      checked: m.checked,\n      notes: m.notes,\n    })));\n  }\n\n  // Add paint from estimate line items\n  if (estimates && estimates.length > 0) {\n    for (const estimate of estimates) {\n      const lineItems = (estimate.line_items as any[]) || [];\n      for (const item of lineItems) {\n        if (item.paint_color_name_or_code) {\n          materials.push({\n            name: item.name,\n            paintColor: item.paint_color_name_or_code,\n            sheen: item.sheen,\n            productLine: item.product_line,\n            gallons: item.gallons_estimate,\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    materials: materials.slice(0, 20),\n  };\n}\n\ninterface InvoiceData {\n  count: number;\n  total: number;\n  invoices: Array<{ id: string; customerName: string; jobTitle: string; amount: number; status: string; created: string }>;\n}\n\nexport async function getInvoicesForDateRange(\n  supabase: SupabaseClient,\n  companyId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<InvoiceData> {\n  const { data: invoices } = await supabase\n    .from(\"invoices\")\n    .select(\"id, amount_total, status, created_at, customer:customers(name), job:jobs(title)\")\n    .eq(\"company_id\", companyId)\n    .gte(\"created_at\", startDate.toISOString())\n    .lt(\"created_at\", endDate.toISOString())\n    .order(\"created_at\", { ascending: false });\n\n  const invoicesList = (invoices || []).map((inv) => ({\n    id: inv.id,\n    customerName: (inv.customer as any)?.name || \"Unknown\",\n    jobTitle: (inv.job as any)?.title || \"Unknown\",\n    amount: inv.amount_total,\n    status: inv.status,\n    created: inv.created_at,\n  }));\n\n  const total = invoicesList.reduce((sum, inv) => sum + inv.amount, 0);\n\n  return {\n    count: invoicesList.length,\n    total,\n    invoices: invoicesList.slice(0, 10),\n  };\n}\n\ninterface CustomerData {\n  customers: Array<{ name: string; unpaidCount: number; unpaidTotal: number }>;\n}\n\nexport async function getCustomersWithUnpaidInvoices(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<CustomerData> {\n  const { data: invoices } = await supabase\n    .from(\"invoices\")\n    .select(\"customer_id, amount_total, customer:customers(name)\")\n    .eq(\"company_id\", companyId)\n    .neq(\"status\", \"paid\")\n    .order(\"created_at\", { ascending: false });\n\n  // Group by customer\n  const customerMap = new Map<string, { name: string; unpaidCount: number; unpaidTotal: number }>();\n\n  for (const invoice of invoices || []) {\n    const customerId = invoice.customer_id;\n    const customerName = (invoice.customer as any)?.name || \"Unknown\";\n    const existing = customerMap.get(customerId) || { name: customerName, unpaidCount: 0, unpaidTotal: 0 };\n    existing.unpaidCount += 1;\n    existing.unpaidTotal += invoice.amount_total;\n    customerMap.set(customerId, existing);\n  }\n\n  const customers = Array.from(customerMap.values()).slice(0, 10);\n\n  return { customers };\n}\n\ninterface RelationshipQueryData {\n  count: number;\n  jobs: Array<{\n    id: string;\n    title: string;\n    customerName: string;\n    estimateStatus: string;\n    acceptedAt: string | null;\n  }>;\n}\n\nexport async function getJobsWithAcceptedEstimatesButNoInvoice(\n  supabase: SupabaseClient,\n  companyId: string\n): Promise<RelationshipQueryData> {\n  // Get all jobs with accepted estimates\n  const { data: estimates } = await supabase\n    .from(\"estimates\")\n    .select(\"job_id, status, accepted_at, job:jobs(id, title, customer:customers(name))\")\n    .eq(\"company_id\", companyId)\n    .eq(\"status\", \"accepted\");\n\n  if (!estimates || estimates.length === 0) {\n    return { count: 0, jobs: [] };\n  }\n\n  const jobIds = estimates.map((e) => e.job_id).filter((id) => id !== null) as string[];\n\n  // Get invoices for these jobs\n  const { data: invoices } = await supabase\n    .from(\"invoices\")\n    .select(\"job_id\")\n    .eq(\"company_id\", companyId)\n    .in(\"job_id\", jobIds);\n\n  const jobsWithInvoices = new Set((invoices || []).map((inv) => inv.job_id));\n\n  // Filter estimates for jobs without invoices\n  const jobsWithoutInvoices = estimates\n    .filter((est) => est.job_id && !jobsWithInvoices.has(est.job_id))\n    .map((est) => {\n      const job = est.job as any;\n      return {\n        id: est.job_id!,\n        title: job?.title || \"Unknown\",\n        customerName: job?.customer?.name || \"Unknown\",\n        estimateStatus: est.status,\n        acceptedAt: est.accepted_at,\n      };\n    });\n\n  return {\n    count: jobsWithoutInvoices.length,\n    jobs: jobsWithoutInvoices.slice(0, 10),\n  };\n}\n","// Intent classification for Matte AI Assistant\n// Maps user questions to specific data queries\n\nexport type MatteIntent =\n  // Existing specific intents (for backward compatibility)\n  | \"UNPAID_INVOICES\"\n  | \"OVERDUE_INVOICES\"\n  | \"PAYMENTS_THIS_WEEK\"\n  | \"JOBS_TODAY\"\n  | \"JOBS_TOMORROW\"\n  | \"JOBS_IN_PROGRESS\"\n  | \"STUCK_JOBS\"\n  | \"MATERIALS_TODAY\"\n  | \"MATERIALS_TOMORROW\"\n  | \"JOBS_MISSING_MATERIALS\"\n  | \"FOCUS_TODAY\"\n  | \"GENERAL_SUMMARY\"\n  | \"TOTAL_JOBS\"\n  | \"TOTAL_REVENUE\"\n  | \"JOBS_THIS_WEEK\"\n  | \"ACTIVE_JOBS\"\n  | \"JOBS_BY_STATUS\"\n  // New flexible intents (for entity-based queries)\n  | \"JOB_LOOKUP\"\n  | \"ESTIMATE_LOOKUP\"\n  | \"INVOICE_LOOKUP\"\n  | \"CUSTOMER_LOOKUP\"\n  | \"MATERIAL_LOOKUP\"\n  | \"RELATIONSHIP_QUERY\"\n  | \"OUT_OF_SCOPE\";\n\n// Entity detection results\nexport interface DetectedEntities {\n  jobIdentifier?: string; // Job name, customer name, or address keyword\n  customerName?: string;\n  dateRange?: { start: Date; end: Date } | \"today\" | \"tomorrow\" | \"this_week\" | \"last_month\";\n  dataType?: \"jobs\" | \"estimates\" | \"invoices\" | \"materials\" | \"paint\" | \"customers\" | \"payments\";\n  relationship?: \"accepted_no_invoice\" | \"unpaid\" | \"overdue\";\n}\n\ninterface IntentPattern {\n  intent: MatteIntent;\n  keywords: string[];\n  patterns: RegExp[];\n}\n\nconst intentPatterns: IntentPattern[] = [\n  // Date-specific queries first (more specific)\n  // Check materials queries BEFORE jobs queries to avoid conflicts\n  {\n    intent: \"MATERIALS_TODAY\",\n    keywords: [\"materials today\", \"need today\", \"paint today\", \"what materials do i need\", \"what materials\", \"materials i need\"],\n    patterns: [\n      /what.*material.*(need|today)/i,\n      /material.*(need|today)/i,\n      /need.*material/i,\n      /material.*today/i,\n      /(what|which).*material/i,\n      /paint.*today/i,\n      /what.*(paint|supplies|materials).*need/i,\n      /what.*(materials|paint|supplies).*for.*today/i,\n    ],\n  },\n  {\n    intent: \"MATERIALS_TOMORROW\",\n    keywords: [\"materials tomorrow\", \"need tomorrow\", \"paint tomorrow\"],\n    patterns: [/material.*tomorrow/i, /need.*tomorrow/i, /paint.*tomorrow/i],\n  },\n  {\n    intent: \"JOBS_TODAY\",\n    keywords: [\"jobs today\", \"today's jobs\", \"scheduled today\", \"what do i have today\", \"how many jobs today\"],\n    patterns: [\n      /how.*many.*job.*today/i,\n      /job.*today/i,\n      /today.*job/i,\n      /what.*(job|work|scheduled).*today/i,\n      /scheduled.*today/i,\n      /(what|which).*have.*today/i,\n      /what.*do.*i.*have.*today/i,\n    ],\n  },\n  {\n    intent: \"JOBS_TOMORROW\",\n    keywords: [\"jobs tomorrow\", \"tomorrow's jobs\", \"scheduled tomorrow\"],\n    patterns: [/job.*tomorrow/i, /tomorrow.*job/i, /scheduled.*tomorrow/i],\n  },\n  {\n    intent: \"PAYMENTS_THIS_WEEK\",\n    keywords: [\"payments this week\", \"paid this week\", \"received this week\"],\n    patterns: [/payment.*this.*week/i, /paid.*this.*week/i, /received.*this.*week/i],\n  },\n  {\n    intent: \"JOBS_THIS_WEEK\",\n    keywords: [\"jobs this week\", \"new jobs this week\", \"jobs added this week\"],\n    patterns: [/job.*this.*week/i, /new.*job.*this.*week/i, /job.*added.*this.*week/i],\n  },\n  // Payment queries\n  {\n    intent: \"UNPAID_INVOICES\",\n    keywords: [\"unpaid\", \"haven't paid\", \"hasn't paid\", \"not paid\", \"outstanding\", \"pending payment\"],\n    patterns: [\n      /who.*(hasn't|has not|haven't|have not).*paid/i,\n      /unpaid.*invoice/i,\n      /who.*owe/i,\n      /outstanding.*payment/i,\n    ],\n  },\n  {\n    intent: \"OVERDUE_INVOICES\",\n    keywords: [\"overdue\", \"late payment\", \"past due\"],\n    patterns: [/overdue/i, /late.*payment/i, /past.*due/i],\n  },\n  // Job status queries\n  {\n    intent: \"JOBS_IN_PROGRESS\",\n    keywords: [\"in progress\", \"active jobs\", \"working on\"],\n    patterns: [/in.*progress/i, /active.*job/i, /working.*on/i],\n  },\n  {\n    intent: \"STUCK_JOBS\",\n    keywords: [\"stuck\", \"same status\", \"not moving\", \"haven't changed\"],\n    patterns: [/stuck/i, /same.*status/i, /not.*moving/i, /haven't.*changed/i],\n  },\n  {\n    intent: \"JOBS_MISSING_MATERIALS\",\n    keywords: [\"missing materials\", \"no materials\", \"need materials\"],\n    patterns: [/missing.*material/i, /no.*material/i, /need.*material/i],\n  },\n  {\n    intent: \"FOCUS_TODAY\",\n    keywords: [\"what should i work on\", \"focus today\", \"priority today\", \"what to do\"],\n    patterns: [\n      /what.*should.*work/i,\n      /focus.*today/i,\n      /priority.*today/i,\n      /what.*to.*do/i,\n      /what.*do.*today/i,\n    ],\n  },\n  // Dashboard/metrics queries (less specific, check after date-specific)\n  {\n    intent: \"TOTAL_JOBS\",\n    keywords: [\"total jobs\", \"how many jobs\", \"all jobs\"],\n    patterns: [/total.*job/i, /how.*many.*job(?!.*today|.*tomorrow|.*week)/i, /all.*job/i],\n  },\n  {\n    intent: \"ACTIVE_JOBS\",\n    keywords: [\"active jobs\", \"how many active\", \"current jobs\"],\n    patterns: [/active.*job/i, /how.*many.*active/i, /current.*job/i],\n  },\n  {\n    intent: \"TOTAL_REVENUE\",\n    keywords: [\"total revenue\", \"total invoiced\", \"how much revenue\", \"total money\"],\n    patterns: [/total.*revenue/i, /total.*invoiced/i, /how.*much.*revenue/i, /total.*money/i],\n  },\n  {\n    intent: \"JOBS_BY_STATUS\",\n    keywords: [\"jobs by status\", \"how many scheduled\", \"how many in progress\", \"status breakdown\"],\n    patterns: [/job.*by.*status/i, /how.*many.*scheduled/i, /how.*many.*in.*progress/i, /status.*breakdown/i],\n  },\n  {\n    intent: \"GENERAL_SUMMARY\",\n    keywords: [\"summary\", \"overview\", \"tell me about\", \"tell me\", \"about my\"],\n    patterns: [/summary/i, /overview/i, /tell.*me.*about/i, /tell.*me/i, /about.*my/i],\n  },\n  // New flexible intents\n  {\n    intent: \"RELATIONSHIP_QUERY\",\n    keywords: [\"accepted but no invoice\", \"estimate accepted no invoice\", \"not invoiced\"],\n    patterns: [\n      /accepted.*(but|without|no).*invoice/i,\n      /estimate.*(but|without|no).*invoice/i,\n      /not.*invoiced/i,\n    ],\n  },\n  {\n    intent: \"CUSTOMER_LOOKUP\",\n    keywords: [\"which customers owe\", \"customers haven't paid\", \"customers unpaid\"],\n    patterns: [/which.*customer.*owe/i, /customer.*(unpaid|haven't paid|owe)/i],\n  },\n];\n\nexport function classifyIntent(userInput: string): MatteIntent {\n  const normalized = userInput.toLowerCase().trim();\n\n  // Check patterns first (more specific)\n  for (const { intent, patterns } of intentPatterns) {\n    if (patterns.some((pattern) => pattern.test(normalized))) {\n      return intent;\n    }\n  }\n\n  // Check keywords (less specific)\n  for (const { intent, keywords } of intentPatterns) {\n    if (keywords.some((keyword) => normalized.includes(keyword))) {\n      return intent;\n    }\n  }\n\n  // Try entity-based classification before giving up\n  const entities = detectEntities(normalized);\n\n  if (entities.jobIdentifier && entities.dataType === \"estimates\") {\n    return \"ESTIMATE_LOOKUP\";\n  }\n  if (entities.jobIdentifier && (entities.dataType === \"materials\" || entities.dataType === \"paint\")) {\n    return \"MATERIAL_LOOKUP\";\n  }\n  if (entities.jobIdentifier) {\n    return \"JOB_LOOKUP\";\n  }\n  if (entities.dateRange && (entities.dataType === \"invoices\" || entities.dataType === \"payments\")) {\n    return \"INVOICE_LOOKUP\";\n  }\n\n  // If query mentions jobs/materials/invoices but no specific intent matched, use general summary\n  if (/(job|material|invoice|customer|payment|estimate)/i.test(normalized)) {\n    return \"GENERAL_SUMMARY\";\n  }\n\n  // Default to out of scope if no match\n  return \"OUT_OF_SCOPE\";\n}\n\n// Entity detection functions\nexport function detectEntities(userInput: string): DetectedEntities {\n  const normalized = userInput.toLowerCase().trim();\n  const entities: DetectedEntities = {};\n\n  // Detect data type\n  if (/(estimate|quoted|quote)/i.test(normalized)) {\n    entities.dataType = \"estimates\";\n  } else if (/(material|paint|color|sheen|gallon)/i.test(normalized)) {\n    entities.dataType = normalized.includes(\"paint\") ? \"paint\" : \"materials\";\n  } else if (/(invoice)/i.test(normalized)) {\n    entities.dataType = \"invoices\";\n  } else if (/(payment|paid|received)/i.test(normalized)) {\n    entities.dataType = \"payments\";\n  } else if (/(customer)/i.test(normalized)) {\n    entities.dataType = \"customers\";\n  } else if (/(job)/i.test(normalized)) {\n    entities.dataType = \"jobs\";\n  }\n\n  // Detect relationship patterns\n  if (/accepted.*(but|without|no).*invoice/i.test(normalized)) {\n    entities.relationship = \"accepted_no_invoice\";\n  } else if (/(unpaid|not paid|haven't paid|outstanding)/i.test(normalized)) {\n    entities.relationship = \"unpaid\";\n  } else if (/(overdue|late|past due)/i.test(normalized)) {\n    entities.relationship = \"overdue\";\n  }\n\n  // Detect date ranges\n  if (/(today|scheduled today)/i.test(normalized)) {\n    entities.dateRange = \"today\";\n  } else if (/(tomorrow)/i.test(normalized)) {\n    entities.dateRange = \"tomorrow\";\n  } else if (/(this week)/i.test(normalized)) {\n    entities.dateRange = \"this_week\";\n  } else if (/(last month)/i.test(normalized)) {\n    entities.dateRange = \"last_month\";\n  }\n\n  // Detect job identifier (customer name, job keyword)\n  // More flexible: look for words that might be customer names or job identifiers\n  // Remove common stop words first\n  const stopWords = ['the', 'my', 'a', 'an', 'for', 'about', 'tell', 'me', 'what', 'how', 'many', 'much', 'is', 'are', 'do', 'does', 'have', 'has', 'need', 'needs', 'all', 'some', 'any'];\n  const words = normalized.split(/\\s+/).filter(w => w.length > 2 && !stopWords.includes(w));\n  \n  // Look for patterns like \"johnsons house\", \"smith job\", \"customer name\"\n  const jobPatterns = [\n    /(?:for|job|customer|about)\\s+([a-z]+(?:\\s+[a-z]+)?)/i,\n    /([a-z]+)\\s+(?:house|job|exterior|interior|property|project)/i,\n    /([a-z]+(?:\\s+[a-z]+)?)\\s+(?:how much|how many|paint|materials|estimate|invoice)/i,\n  ];\n  \n  for (const pattern of jobPatterns) {\n    const match = normalized.match(pattern);\n    if (match && match[1] && match[1].length > 2) {\n      entities.jobIdentifier = match[1].trim();\n      break;\n    }\n  }\n  \n  // If no pattern match, try to extract meaningful words (likely customer/job names)\n  // Take words that aren't common query words\n  if (!entities.jobIdentifier && words.length > 0) {\n    // Filter out common query words\n    const queryWords = ['jobs', 'job', 'materials', 'material', 'paint', 'invoices', 'invoice', 'customers', 'customer', 'payments', 'payment', 'estimates', 'estimate', 'today', 'tomorrow', 'week', 'month', 'year'];\n    const potentialIdentifiers = words.filter(w => !queryWords.includes(w));\n    if (potentialIdentifiers.length > 0) {\n      // Take first 1-2 words as potential identifier\n      entities.jobIdentifier = potentialIdentifiers.slice(0, 2).join(' ');\n    }\n  }\n\n  return entities;\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}