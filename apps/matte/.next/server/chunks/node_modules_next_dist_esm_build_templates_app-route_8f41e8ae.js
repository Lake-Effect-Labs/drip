module.exports=[91527,e=>{"use strict";var t=e.i(47909),a=e.i(74017),o=e.i(96250),s=e.i(59756),n=e.i(61916),i=e.i(74677),r=e.i(69741),d=e.i(16795),l=e.i(87718),c=e.i(95169),u=e.i(47587),m=e.i(66012),h=e.i(70101),p=e.i(26937),b=e.i(10372),w=e.i(93695);e.i(52474);var y=e.i(5232),_=e.i(89171),f=e.i(32418);let g=[{intent:"MATERIALS_TODAY",keywords:["materials today","need today","paint today","what materials do i need","what materials","materials i need"],patterns:[/what.*material.*(need|today)/i,/material.*(need|today)/i,/need.*material/i,/material.*today/i,/(what|which).*material/i,/paint.*today/i,/what.*(paint|supplies|materials).*need/i,/what.*(materials|paint|supplies).*for.*today/i]},{intent:"MATERIALS_TOMORROW",keywords:["materials tomorrow","need tomorrow","paint tomorrow"],patterns:[/material.*tomorrow/i,/need.*tomorrow/i,/paint.*tomorrow/i]},{intent:"JOBS_TODAY",keywords:["jobs today","today's jobs","scheduled today","what do i have today","how many jobs today"],patterns:[/how.*many.*job.*today/i,/job.*today/i,/today.*job/i,/what.*(job|work|scheduled).*today/i,/scheduled.*today/i,/(what|which).*have.*today/i,/what.*do.*i.*have.*today/i]},{intent:"JOBS_TOMORROW",keywords:["jobs tomorrow","tomorrow's jobs","scheduled tomorrow"],patterns:[/job.*tomorrow/i,/tomorrow.*job/i,/scheduled.*tomorrow/i]},{intent:"PAYMENTS_THIS_WEEK",keywords:["payments this week","paid this week","received this week"],patterns:[/payment.*this.*week/i,/paid.*this.*week/i,/received.*this.*week/i]},{intent:"JOBS_THIS_WEEK",keywords:["jobs this week","new jobs this week","jobs added this week"],patterns:[/job.*this.*week/i,/new.*job.*this.*week/i,/job.*added.*this.*week/i]},{intent:"UNPAID_INVOICES",keywords:["unpaid","haven't paid","hasn't paid","not paid","outstanding","pending payment"],patterns:[/who.*(hasn't|has not|haven't|have not).*paid/i,/unpaid.*invoice/i,/who.*owe/i,/outstanding.*payment/i]},{intent:"OVERDUE_INVOICES",keywords:["overdue","late payment","past due"],patterns:[/overdue/i,/late.*payment/i,/past.*due/i]},{intent:"JOBS_IN_PROGRESS",keywords:["in progress","active jobs","working on"],patterns:[/in.*progress/i,/active.*job/i,/working.*on/i]},{intent:"STUCK_JOBS",keywords:["stuck","same status","not moving","haven't changed"],patterns:[/stuck/i,/same.*status/i,/not.*moving/i,/haven't.*changed/i]},{intent:"JOBS_MISSING_MATERIALS",keywords:["missing materials","no materials","need materials"],patterns:[/missing.*material/i,/no.*material/i,/need.*material/i]},{intent:"FOCUS_TODAY",keywords:["what should i work on","focus today","priority today","what to do"],patterns:[/what.*should.*work/i,/focus.*today/i,/priority.*today/i,/what.*to.*do/i,/what.*do.*today/i]},{intent:"TOTAL_JOBS",keywords:["total jobs","how many jobs","all jobs"],patterns:[/total.*job/i,/how.*many.*job(?!.*today|.*tomorrow|.*week)/i,/all.*job/i]},{intent:"ACTIVE_JOBS",keywords:["active jobs","how many active","current jobs"],patterns:[/active.*job/i,/how.*many.*active/i,/current.*job/i]},{intent:"TOTAL_REVENUE",keywords:["total revenue","total invoiced","how much revenue","total money"],patterns:[/total.*revenue/i,/total.*invoiced/i,/how.*much.*revenue/i,/total.*money/i]},{intent:"JOBS_BY_STATUS",keywords:["jobs by status","how many scheduled","how many in progress","status breakdown"],patterns:[/job.*by.*status/i,/how.*many.*scheduled/i,/how.*many.*in.*progress/i,/status.*breakdown/i]},{intent:"GENERAL_SUMMARY",keywords:["summary","overview","tell me about","tell me","about my"],patterns:[/summary/i,/overview/i,/tell.*me.*about/i,/tell.*me/i,/about.*my/i]},{intent:"RELATIONSHIP_QUERY",keywords:["accepted but no invoice","estimate accepted no invoice","not invoiced"],patterns:[/accepted.*(but|without|no).*invoice/i,/estimate.*(but|without|no).*invoice/i,/not.*invoiced/i]},{intent:"CUSTOMER_LOOKUP",keywords:["which customers owe","customers haven't paid","customers unpaid"],patterns:[/which.*customer.*owe/i,/customer.*(unpaid|haven't paid|owe)/i]}];function j(e){let t=e.toLowerCase().trim(),a={};/(estimate|quoted|quote)/i.test(t)?a.dataType="estimates":/(material|paint|color|sheen|gallon)/i.test(t)?a.dataType=t.includes("paint")?"paint":"materials":/(invoice)/i.test(t)?a.dataType="invoices":/(payment|paid|received)/i.test(t)?a.dataType="payments":/(customer)/i.test(t)?a.dataType="customers":/(job)/i.test(t)&&(a.dataType="jobs"),/accepted.*(but|without|no).*invoice/i.test(t)?a.relationship="accepted_no_invoice":/(unpaid|not paid|haven't paid|outstanding)/i.test(t)?a.relationship="unpaid":/(overdue|late|past due)/i.test(t)&&(a.relationship="overdue"),/(today|scheduled today)/i.test(t)?a.dateRange="today":/(tomorrow)/i.test(t)?a.dateRange="tomorrow":/(this week)/i.test(t)?a.dateRange="this_week":/(last month)/i.test(t)&&(a.dateRange="last_month");let o=["the","my","a","an","for","about","tell","me","what","how","many","much","is","are","do","does","have","has","need","needs","all","some","any"],s=t.split(/\s+/).filter(e=>e.length>2&&!o.includes(e));for(let e of[/(?:for|job|customer|about)\s+([a-z]+(?:\s+[a-z]+)?)/i,/([a-z]+)\s+(?:house|job|exterior|interior|property|project)/i,/([a-z]+(?:\s+[a-z]+)?)\s+(?:how much|how many|paint|materials|estimate|invoice)/i]){let o=t.match(e);if(o&&o[1]&&o[1].length>2){a.jobIdentifier=o[1].trim();break}}if(!a.jobIdentifier&&s.length>0){let e=["jobs","job","materials","material","paint","invoices","invoice","customers","customer","payments","payment","estimates","estimate","today","tomorrow","week","month","year"],t=s.filter(t=>!e.includes(t));t.length>0&&(a.jobIdentifier=t.slice(0,2).join(" "))}return a}async function v(e,t){let{data:a}=await e.from("invoices").select("id, amount_total, created_at, customer:customers(name)").eq("company_id",t).neq("status","paid").order("created_at",{ascending:!1}),o=(a||[]).map(e=>({id:e.id,customerName:e.customer?.name||"Unknown",amount:e.amount_total,created:e.created_at})),s=o.reduce((e,t)=>e+t.amount,0);return{count:o.length,total:s,invoices:o.slice(0,10)}}async function T(e,t){let a=new Date;a.setDate(a.getDate()-30);let{data:o}=await e.from("invoices").select("id, amount_total, created_at, customer:customers(name)").eq("company_id",t).neq("status","paid").lt("created_at",a.toISOString()).order("created_at",{ascending:!1}),s=(o||[]).map(e=>({id:e.id,customerName:e.customer?.name||"Unknown",amount:e.amount_total,created:e.created_at})),n=s.reduce((e,t)=>e+t.amount,0);return{count:s.length,total:n,invoices:s.slice(0,10)}}async function O(e,t){let a=new Date;a.setDate(a.getDate()-7);let{data:o}=await e.from("invoices").select("id").eq("company_id",t),s=o?.map(e=>e.id)||[];if(0===s.length)return{count:0,total:0,payments:[]};let{data:n}=await e.from("invoice_payments").select("amount, paid_at, invoice:invoices(customer:customers(name))").in("invoice_id",s).gte("paid_at",a.toISOString()).order("paid_at",{ascending:!1}),i=(n||[]).map(e=>({amount:e.amount,customerName:e.invoice?.customer?.name||"Unknown",date:e.paid_at})),r=i.reduce((e,t)=>e+t.amount,0);return{count:i.length,total:r,payments:i.slice(0,10)}}async function k(e,t,a){let o=a.getFullYear(),s=a.getMonth(),n=a.getDate(),i=`${o}-${String(s+1).padStart(2,"0")}-${String(n).padStart(2,"0")}`,{data:r,error:d}=await e.from("jobs").select("id, title, status, scheduled_date, scheduled_end_date, scheduled_time, customer:customers(name)").eq("company_id",t).not("scheduled_date","is",null);if(d)return console.error("Error fetching jobs for date:",d,"Target date:",i),{count:0,jobs:[]};let l=(r||[]).filter(e=>{let t,a;if(!e.scheduled_date)return!1;if(t=e.scheduled_date.includes("T")?e.scheduled_date.split("T")[0]:e.scheduled_date,!e.scheduled_end_date)return t.trim()===i.trim();a=e.scheduled_end_date.includes("T")?e.scheduled_end_date.split("T")[0]:e.scheduled_end_date;let o=t.trim(),s=a.trim(),n=i.trim();return o<=n&&s>=n});l.sort((e,t)=>{if(e.scheduled_date!==t.scheduled_date)return(e.scheduled_date||"").localeCompare(t.scheduled_date||"");let a=e.scheduled_time||"00:00",o=t.scheduled_time||"00:00";return a.localeCompare(o)}),console.log("getJobsForDate - Target date:",i),console.log("getJobsForDate - All jobs with dates:",r?.length||0),console.log("getJobsForDate - Matching jobs:",l.length),r&&r.length>0?console.log("getJobsForDate - All job scheduled dates:",r.map(e=>({id:e.id,title:e.title,scheduled_date:e.scheduled_date,datePart:e.scheduled_date?.split("T")[0],matches:e.scheduled_date?.split("T")[0]===i}))):console.log("getJobsForDate - No jobs found with scheduled_date");let c=l.map(e=>({id:e.id,title:e.title,customerName:e.customer?.name||"Unknown",status:e.status,scheduledDate:e.scheduled_date,scheduledEndDate:e.scheduled_end_date||void 0}));return{count:c.length,jobs:c}}async function R(e,t){let{data:a}=await e.from("jobs").select("id, title, status, customer:customers(name)").eq("company_id",t).in("status",["in_progress","scheduled"]).order("updated_at",{ascending:!1}),o=(a||[]).map(e=>({id:e.id,title:e.title,customerName:e.customer?.name||"Unknown",status:e.status}));return{count:o.length,jobs:o.slice(0,10)}}async function S(e,t){let a=new Date;a.setDate(a.getDate()-14);let{data:o}=await e.from("jobs").select("id, title, status, updated_at, customer:customers(name)").eq("company_id",t).lt("updated_at",a.toISOString()).in("status",["scheduled","in_progress","estimate_sent"]).order("updated_at",{ascending:!0}),s=(o||[]).map(e=>({id:e.id,title:e.title,customerName:e.customer?.name||"Unknown",status:e.status}));return{count:s.length,jobs:s.slice(0,10)}}async function I(e,t,a){let o=a.toISOString().split("T")[0],s=new Date(a);s.setDate(s.getDate()+1);let n=s.toISOString().split("T")[0],{data:i}=await e.from("jobs").select("id, title, scheduled_date, customer:customers(name)").eq("company_id",t).gte("scheduled_date",o).lt("scheduled_date",n);if(!i||0===i.length)return{materials:[]};let r=i.map(e=>e.id),{data:d}=await e.from("job_materials").select("name, job:jobs(title, customer:customers(name))").in("job_id",r).eq("checked",!1);return{materials:(d||[]).map(e=>({name:e.name,jobTitle:e.job?.title||"Unknown",customerName:e.job?.customer?.name||"Unknown"})).slice(0,20)}}async function A(e,t){let{data:a}=await e.from("jobs").select("id, title, status, customer:customers(name)").eq("company_id",t).in("status",["scheduled","in_progress"]);if(!a||0===a.length)return{count:0,jobs:[]};let o=a.map(e=>e.id),{data:s}=await e.from("job_materials").select("job_id").in("job_id",o),n=new Set((s||[]).map(e=>e.job_id)),i=a.filter(e=>!n.has(e.id)).map(e=>({id:e.id,title:e.title,customerName:e.customer?.name||"Unknown",status:e.status}));return{count:i.length,jobs:i.slice(0,10)}}async function E(e,t){let a=new Date,o=await k(e,t,a),s=await v(e,t);return{jobsToday:o.count,unpaidInvoices:s.count,unpaidTotal:s.total}}async function N(e,t){let[a,o,s]=await Promise.all([e.from("jobs").select("id, status").eq("company_id",t),e.from("invoices").select("id, amount_total, status").eq("company_id",t),v(e,t)]),n=a.data||[],i=o.data||[],r=n.filter(e=>["scheduled","in_progress"].includes(e.status)).length,d=i.reduce((e,t)=>e+t.amount_total,0),l=i.filter(e=>"paid"===e.status).reduce((e,t)=>e+t.amount_total,0);return{totalJobs:n.length,activeJobs:r,totalInvoiced:d,totalPaid:l,unpaidCount:s.count}}async function $(e,t,a){let o=a.toLowerCase().trim();if("my"===o||"all"===o||o.length<2)return{count:0,jobs:[]};let s=o.split(/\s+/).filter(e=>e.length>1),n=e.from("jobs").select("id, title, status, scheduled_date, customer:customers(name)").eq("company_id",t);if(s.length>0){let e=s.map(e=>`title.ilike.%${e}%,customer.name.ilike.%${e}%`).join(",");n=n.or(e)}else n=n.or(`title.ilike.%${o}%,customer.name.ilike.%${o}%`);let{data:i}=await n,r=(i||[]).map(e=>({id:e.id,title:e.title,customerName:e.customer?.name||"Unknown",status:e.status,scheduledDate:e.scheduled_date}));return{count:r.length,jobs:r.slice(0,10)}}async function C(e,t,a){let{data:o}=await e.from("estimates").select("id, status, sqft, accepted_at, line_items:estimate_line_items(name, price, paint_color_name_or_code, sheen)").eq("company_id",t).eq("job_id",a).order("created_at",{ascending:!1}),s=(o||[]).map(e=>{let t=e.line_items||[],a=t.reduce((e,t)=>e+(t.price||0),0);return{id:e.id,status:e.status,sqft:e.sqft,acceptedAt:e.accepted_at,lineItems:t.slice(0,10).map(e=>({name:e.name,price:e.price,paintColor:e.paint_color_name_or_code,sheen:e.sheen})),total:a}}),n=s.reduce((e,t)=>e+(t.total||0),0);return{count:s.length,total:n,estimates:s}}async function D(e,t,a){let{data:o}=await e.from("job_materials").select("name, checked, notes, job:jobs(title, customer:customers(name))").eq("job_id",a),{data:s}=await e.from("estimates").select("line_items:estimate_line_items(name, paint_color_name_or_code, sheen, product_line, gallons_estimate)").eq("company_id",t).eq("job_id",a).eq("status","accepted"),n=[];if(o&&o.length>0){let e=o[0].job;n.push(...o.map(t=>({name:t.name,jobTitle:e?.title||"Unknown",customerName:e?.customer?.name||"Unknown",checked:t.checked,notes:t.notes})))}if(s&&s.length>0)for(let e of s)for(let t of e.line_items||[])t.paint_color_name_or_code&&n.push({name:t.name,paintColor:t.paint_color_name_or_code,sheen:t.sheen,productLine:t.product_line,gallons:t.gallons_estimate});return{materials:n.slice(0,20)}}async function U(e,t,a,o){let{data:s}=await e.from("invoices").select("id, amount_total, status, created_at, customer:customers(name), job:jobs(title)").eq("company_id",t).gte("created_at",a.toISOString()).lt("created_at",o.toISOString()).order("created_at",{ascending:!1}),n=(s||[]).map(e=>({id:e.id,customerName:e.customer?.name||"Unknown",jobTitle:e.job?.title||"Unknown",amount:e.amount_total,status:e.status,created:e.created_at})),i=n.reduce((e,t)=>e+t.amount,0);return{count:n.length,total:i,invoices:n.slice(0,10)}}async function J(e,t){let{data:a}=await e.from("invoices").select("customer_id, amount_total, customer:customers(name)").eq("company_id",t).neq("status","paid").order("created_at",{ascending:!1}),o=new Map;for(let e of a||[]){let t=e.customer_id,a=e.customer?.name||"Unknown",s=o.get(t)||{name:a,unpaidCount:0,unpaidTotal:0};s.unpaidCount+=1,s.unpaidTotal+=e.amount_total,o.set(t,s)}return{customers:Array.from(o.values()).slice(0,10)}}async function x(e,t){let{data:a}=await e.from("estimates").select("job_id, status, accepted_at, job:jobs(id, title, customer:customers(name))").eq("company_id",t).eq("status","accepted");if(!a||0===a.length)return{count:0,jobs:[]};let o=a.map(e=>e.job_id).filter(e=>null!==e),{data:s}=await e.from("invoices").select("job_id").eq("company_id",t).in("job_id",o),n=new Set((s||[]).map(e=>e.job_id)),i=a.filter(e=>e.job_id&&!n.has(e.job_id)).map(e=>{let t=e.job;return{id:e.job_id,title:t?.title||"Unknown",customerName:t?.customer?.name||"Unknown",estimateStatus:e.status,acceptedAt:e.accepted_at}});return{count:i.length,jobs:i.slice(0,10)}}let q=`ROLE

You are Matte AI, a read-only analytical assistant for a painting company.

Your ONLY source of truth is the structured data explicitly provided to you in the context of the request.

You are not allowed to:
- Guess
- Infer missing values
- Assume typical industry behavior
- Fill gaps with "common sense"
- Use external knowledge
- Answer from memory

If the data is not present, you must say so.

ALLOWED DATA

You may ONLY answer questions using data from:
- Jobs
- Estimates
- Invoices
- Inventory items
- Job materials checklists
- Stores
- Customers
- Payments (if provided)
- Company settings

If a field, record, or relationship is missing, you must treat it as unknown, not false.

ANSWER RULES (CRITICAL)

Rule 1 â€” No Data = No Answer
If the question cannot be answered exactly with the provided data:
Respond with: "I don't have enough data to answer that."
Optionally add: "Here's what I would need to answer it accurately: â€¦"

Rule 2 â€” Cite the Source Internally
Every answer must state where the data came from.
Example: "Based on 12 completed jobs from Januaryâ€“March 2026â€¦"
If you can't cite the source â†’ You cannot answer.

Rule 3 â€” Never Extrapolate
Do NOT:
- Project future totals
- Average across incomplete datasets
- Estimate missing consumption
- Assume defaults unless explicitly provided

Bad âŒ: "You probably used about 20 gallonsâ€¦"
Good âœ…: "Recorded job materials show 14 gallons across 5 jobs."

Rule 4 â€” Ask to Clarify, Don't Guess
If the question is ambiguous, ask one clarifying question and stop.
Example: "Do you want only completed jobs, or all jobs including scheduled?"

RESPONSE FORMAT (MANDATORY)

All responses must follow this structure:

ðŸ“Š Answer
(Short, direct answer or "I don't have enough data.")

ðŸ“ Data Used
- Data source(s)
- Date range
- Filters applied

âš ï¸ Limitations
- What is missing or incomplete
- Any assumptions explicitly NOT made

HARD CONSTRAINTS (DO NOT VIOLATE)
- NEVER answer with "typically", "usually", or "most painters"
- NEVER invent quantities
- NEVER use external knowledge
- NEVER be confident without citations
- NEVER hide uncertainty

PRIMARY GOAL
Your goal is trust, not completeness.
A correct "I don't know" is always better than a wrong answer.

FINAL CHECK (SELF-EVALUATION)
Before responding, silently verify:
- Did I use only provided data?
- Can I cite the source?
- Did I avoid assumptions?
- Did I clearly state limitations?

If any answer is "no" â†’ do not answer.`;async function L(e){try{let t=await (0,f.createClient)(),a=(0,f.createAdminClient)(),{data:{user:o}}=await t.auth.getUser();if(!o)return _.NextResponse.json({error:"Unauthorized"},{status:401});let{message:s}=await e.json();if(!s||"string"!=typeof s)return _.NextResponse.json({error:"Message required"},{status:400});let{data:n}=await a.from("company_users").select("company_id").eq("user_id",o.id).maybeSingle();if(!n)return _.NextResponse.json({error:"Company not found"},{status:404});let i=n.company_id,r=function(e){let t=e.toLowerCase().trim();for(let{intent:e,patterns:a}of g)if(a.some(e=>e.test(t)))return e;for(let{intent:e,keywords:a}of g)if(a.some(e=>t.includes(e)))return e;let a=j(t);return a.jobIdentifier&&"estimates"===a.dataType?"ESTIMATE_LOOKUP":a.jobIdentifier&&("materials"===a.dataType||"paint"===a.dataType)?"MATERIAL_LOOKUP":a.jobIdentifier?"JOB_LOOKUP":a.dateRange&&("invoices"===a.dataType||"payments"===a.dataType)?"INVOICE_LOOKUP":/(job|material|invoice|customer|payment|estimate)/i.test(t)?"GENERAL_SUMMARY":"OUT_OF_SCOPE"}(s),d=j(s),l={},c="",u="";switch(r){case"UNPAID_INVOICES":{let e=await v(a,i);l=e;let t=(e.total/100).toFixed(2);c=`The user asked about unpaid invoices. Here's the data:
- Count: ${e.count}
- Total: $${t}
- Invoices: ${JSON.stringify(e.invoices.map(e=>({customer:e.customerName,amount:`$${(e.amount/100).toFixed(2)}`})))}

Respond concisely about who hasn't paid.`;break}case"OVERDUE_INVOICES":{let e=await T(a,i);l=e;let t=(e.total/100).toFixed(2);c=`The user asked about overdue invoices. Here's the data:
- Count: ${e.count}
- Total: $${t}
- Invoices: ${JSON.stringify(e.invoices.map(e=>({customer:e.customerName,amount:`$${(e.amount/100).toFixed(2)}`})))}

Respond concisely about overdue invoices.`;break}case"PAYMENTS_THIS_WEEK":{let e=await O(a,i);l=e;let t=(e.total/100).toFixed(2);c=`The user asked about payments this week. Here's the data:
- Count: ${e.count}
- Total: $${t}
- Payments: ${JSON.stringify(e.payments.map(e=>({customer:e.customerName,amount:`$${(e.amount/100).toFixed(2)}`})))}

Respond concisely about payments received this week.`;break}case"JOBS_TODAY":{let e=new Date,t=new Date(e.getFullYear(),e.getMonth(),e.getDate()),o=await k(a,i,t);l=o;let n=e.toLocaleDateString("en-US",{weekday:"long",month:"long",day:"numeric",year:"numeric"});console.log("JOBS_TODAY - Today date object:",t),console.log("JOBS_TODAY - Today date string:",`${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,"0")}-${String(t.getDate()).padStart(2,"0")}`),console.log("JOBS_TODAY - Result count:",o.count),console.log("JOBS_TODAY - Jobs found:",o.jobs),c=`The user asked: "${s}"

Here is the EXACT data available:
- Date searched: ${n}
- Count: ${o.count}
- Jobs: ${JSON.stringify(o.jobs.map(e=>({title:e.title,customer:e.customerName,status:e.status,scheduledDate:e.scheduledDate})))}

CRITICAL: You must respond using ONLY this data. Use the mandatory format:
ðŸ“Š Answer
ðŸ“ Data Used
âš ï¸ Limitations

If count is 0, your answer must be: "I don't have enough data to answer that. No jobs are scheduled for today in the database."`;break}case"JOBS_TOMORROW":{let e=new Date;e.setDate(e.getDate()+1);let t=await k(a,i,e);l=t,c=`The user asked about jobs tomorrow. Here's the data:
- Count: ${t.count}
- Jobs: ${JSON.stringify(t.jobs.map(e=>({title:e.title,customer:e.customerName,status:e.status})))}

Respond concisely about tomorrow's jobs.`;break}case"JOBS_IN_PROGRESS":{let e=await R(a,i);l=e,c=`The user asked about jobs in progress. Here's the data:
- Count: ${e.count}
- Jobs: ${JSON.stringify(e.jobs.map(e=>({title:e.title,customer:e.customerName,status:e.status})))}

Respond concisely about active jobs.`;break}case"STUCK_JOBS":{let e=await S(a,i);l=e,c=`The user asked about stuck jobs. Here's the data:
- Count: ${e.count}
- Jobs: ${JSON.stringify(e.jobs.map(e=>({title:e.title,customer:e.customerName,status:e.status})))}

Respond concisely about jobs that haven't moved.`;break}case"MATERIALS_TODAY":{let e=await I(a,i,new Date);l=e,c=0===e.materials.length?`The user asked about materials needed for today. There are no materials needed for jobs scheduled today.

Respond concisely: "You don't need any materials for today."`:`The user asked about materials needed for today. Here's the data:
- Materials: ${JSON.stringify(e.materials.map(e=>({name:e.name,job:e.jobTitle,customer:e.customerName})))}

Respond concisely about the materials needed. List the materials and which jobs they're for.`;break}case"MATERIALS_TOMORROW":{let e=new Date;e.setDate(e.getDate()+1);let t=await I(a,i,e);l=t,c=0===t.materials.length?`The user asked about materials needed for tomorrow. There are no materials needed for jobs scheduled tomorrow.

Respond concisely: "You don't need any materials for tomorrow."`:`The user asked about materials needed for tomorrow. Here's the data:
- Materials: ${JSON.stringify(t.materials.map(e=>({name:e.name,job:e.jobTitle,customer:e.customerName})))}

Respond concisely about the materials needed tomorrow. List the materials and which jobs they're for.`;break}case"JOBS_MISSING_MATERIALS":{let e=await A(a,i);l=e,c=`The user asked about jobs missing materials. Here's the data:
- Count: ${e.count}
- Jobs: ${JSON.stringify(e.jobs.map(e=>({title:e.title,customer:e.customerName})))}

Respond concisely about jobs that need materials added.`;break}case"FOCUS_TODAY":{let e=await E(a,i);l=e;let t=(e.unpaidTotal/100).toFixed(2);c=`The user asked what to focus on today. Here's the data:
- Jobs today: ${e.jobsToday}
- Unpaid invoices: ${e.unpaidInvoices}
- Unpaid total: $${t}

Respond concisely about what to work on today.`;break}case"GENERAL_SUMMARY":{let e=await N(a,i),{data:t}=await a.from("jobs").select("id, title, status, customer:customers(name)").eq("company_id",i).order("created_at",{ascending:!1}).limit(20),{data:o}=await a.from("invoices").select("id, amount_total, status, created_at, customer:customers(name)").eq("company_id",i).order("created_at",{ascending:!1}).limit(10),{data:n}=await a.from("customers").select("id, name").eq("company_id",i).order("name").limit(50),r=(e.totalInvoiced/100).toFixed(2),d=(e.totalPaid/100).toFixed(2),u=(t||[]).map(e=>({id:e.id,title:e.title,status:e.status,customerName:e.customer?.name||"Unknown"})),m=(o||[]).map(e=>({id:e.id,amount:e.amount_total,status:e.status,customerName:e.customer?.name||"Unknown",created:e.created_at}));l={generalData:e,recentJobs:u,recentInvoices:m,customers:n},c=`The user asked: "${s}"

Here's what I know about the business:
- Total jobs: ${e.totalJobs}
- Active jobs: ${e.activeJobs}
- Total invoiced: $${r}
- Total paid: $${d}
- Unpaid invoices: ${e.unpaidCount}

Recent jobs (last 20):
${JSON.stringify(u)}

Recent invoices (last 10):
${JSON.stringify(m)}

Customers:
${JSON.stringify(n?.map(e=>({name:e.name}))||[])}

Use this data to answer the user's question. Be specific and helpful. If the question is about a specific job, customer, invoice, or material, provide details from the data above.`;break}case"TOTAL_JOBS":{let e=await N(a,i);l=e,c=`The user asked about total jobs. Here's the data:
- Total jobs: ${e.totalJobs}

Respond concisely with the total number of jobs.`;break}case"TOTAL_REVENUE":{let e=await N(a,i);l=e;let t=(e.totalInvoiced/100).toFixed(2);c=`The user asked about total revenue. Here's the data:
- Total invoiced: $${t}

Respond concisely with the total revenue/invoiced amount.`;break}case"JOBS_THIS_WEEK":{let e=new Date;e.setDate(e.getDate()-7);let{data:t}=await a.from("jobs").select("id, created_at").eq("company_id",i).gte("created_at",e.toISOString()),o=t?.length||0;l={count:o},c=`The user asked about jobs this week. Here's the data:
- Jobs this week: ${o}

Respond concisely with how many jobs were created this week.`;break}case"ACTIVE_JOBS":{let e=await N(a,i);l=e,c=`The user asked about active jobs. Here's the data:
- Active jobs: ${e.activeJobs}

Respond concisely with how many active jobs (scheduled or in progress) they have.`;break}case"JOBS_BY_STATUS":{let{data:e}=await a.from("jobs").select("status").eq("company_id",i),t=(e||[]).reduce((e,t)=>(e[t.status]=(e[t.status]||0)+1,e),{});l={jobsByStatus:t},c=`The user asked about jobs by status. Here's the data:
${JSON.stringify(t)}

Respond concisely with a breakdown of jobs by status.`;break}case"JOB_LOOKUP":case"ESTIMATE_LOOKUP":case"MATERIAL_LOOKUP":{if(!d.jobIdentifier){u="I need a job or customer name to look up that information.";break}let e=d.jobIdentifier.toLowerCase();if("my"===e||"all"===e||e.includes("my ")||e.includes("all ")){await N(a,i);let{data:e}=await a.from("jobs").select("id, title, status, customer:customers(name)").eq("company_id",i).order("created_at",{ascending:!1}).limit(20);l={jobs:e||[]};let t=(e||[]).map(e=>({title:e.title,customer:e.customer?.name||"Unknown",status:e.status}));c=`The user asked about their jobs. Here are their recent jobs:
${JSON.stringify(t)}

Respond concisely about their jobs.`;break}let t=await $(a,i,d.jobIdentifier);if(0===t.count){u=`I don't see any jobs matching "${d.jobIdentifier}". Try asking about a specific customer name or job title.`;break}let o=t.jobs[0];if("ESTIMATE_LOOKUP"===r){let e=await C(a,i,o.id);if(0===e.count){u=`I don't see any estimates for the ${o.title} job.`;break}l=e;let t=(e.total/100).toFixed(2);c=`The user asked about estimates for the "${o.title}" job (customer: ${o.customerName}). Here's the data:
- Count: ${e.count}
- Total: $${t}
- Estimates: ${JSON.stringify(e.estimates.map(e=>({status:e.status,total:`$${(e.total/100).toFixed(2)}`,lineItems:e.lineItems.slice(0,3)})))}

Respond concisely about the estimate amount and status.`}else if("MATERIAL_LOOKUP"===r){let e=await D(a,i,o.id);if(0===e.materials.length){u=`I don't see any materials listed for the ${o.title} job.`;break}l=e,c=`The user asked about materials/paint for the "${o.title}" job (customer: ${o.customerName}). Here's the data:
- Materials: ${JSON.stringify(e.materials.map(e=>({name:e.name,paintColor:e.paintColor,sheen:e.sheen,checked:e.checked})))}

Respond concisely about what materials/paint are needed.`}else l=t,c=`The user asked about jobs matching "${d.jobIdentifier}". Here's the data:
- Count: ${t.count}
- Jobs: ${JSON.stringify(t.jobs.map(e=>({title:e.title,customer:e.customerName,status:e.status,scheduledDate:e.scheduledDate})))}

Respond concisely about the job(s) found.`;break}case"INVOICE_LOOKUP":{let e,t;if("last_month"===d.dateRange){let a=new Date;e=new Date(a.getFullYear(),a.getMonth()-1,1),t=new Date(a.getFullYear(),a.getMonth(),1)}else if("this_week"===d.dateRange){let a=new Date,o=a.getDay();(e=new Date(a)).setDate(a.getDate()-o),(t=new Date(a)).setDate(a.getDate()+(7-o))}else{u="I need a date range (like 'last month' or 'this week') to look up invoices.";break}let o=await U(a,i,e,t);if(0===o.count){u="I don't see any invoices in that date range.";break}l=o;let s=(o.total/100).toFixed(2),n="last_month"===d.dateRange?"last month":"this week";c=`The user asked about invoices for ${n}. Here's the data:
- Count: ${o.count}
- Total: $${s}
- Invoices: ${JSON.stringify(o.invoices.map(e=>({customer:e.customerName,job:e.jobTitle,amount:`$${(e.amount/100).toFixed(2)}`,status:e.status})))}

Respond concisely about the invoices in that period.`;break}case"CUSTOMER_LOOKUP":{let e=await J(a,i);if(0===e.customers.length){u="All customers have paid their invoices!";break}l=e,c=`The user asked about customers who owe money. Here's the data:
- Customers: ${JSON.stringify(e.customers.map(e=>({name:e.name,unpaidCount:e.unpaidCount,total:`$${(e.unpaidTotal/100).toFixed(2)}`})))}

Respond concisely about which customers have unpaid invoices.`;break}case"RELATIONSHIP_QUERY":if("accepted_no_invoice"===d.relationship){let e=await x(a,i);if(0===e.count){u="All jobs with accepted estimates have been invoiced!";break}l=e,c=`The user asked about jobs with accepted estimates but no invoice. Here's the data:
- Count: ${e.count}
- Jobs: ${JSON.stringify(e.jobs.map(e=>({title:e.title,customer:e.customerName,acceptedAt:e.acceptedAt})))}

Respond concisely about which jobs need invoices created.`}break;case"OUT_OF_SCOPE":{let e=s.toLowerCase();if(!/(job|material|invoice|customer|payment|estimate|paint|revenue|money|paid|unpaid)/i.test(e))return _.NextResponse.json({response:"I can only answer questions about your jobs, invoices, estimates, materials, and customers."})}default:{let[e,t,o,n]=await Promise.all([N(a,i),a.from("jobs").select("id, title, status, scheduled_date, scheduled_time, customer:customers(name)").eq("company_id",i).limit(20).order("created_at",{ascending:!1}),a.from("invoices").select("id, amount_total, status, created_at, customer:customers(name), job:jobs(title)").eq("company_id",i).limit(10).order("created_at",{ascending:!1}),a.from("customers").select("id, name, email, phone").eq("company_id",i).limit(10).order("name")]),r=(t.data||[]).map(e=>({title:e.title,status:e.status,customer:e.customer?.name||"Unknown",scheduledDate:e.scheduled_date,scheduledTime:e.scheduled_time})),d=(o.data||[]).map(e=>({customer:e.customer?.name||"Unknown",job:e.job?.title||"Unknown",amount:`$${(e.amount_total/100).toFixed(2)}`,status:e.status})),u=(n.data||[]).map(e=>({name:e.name,email:e.email,phone:e.phone})),{data:m}=await a.from("jobs").select("id").eq("company_id",i),h=m?.map(e=>e.id)||[],{data:p}=h.length>0?await a.from("job_materials").select("name, notes, quantity_decimal, unit, job:jobs(title, customer:customers(name))").in("job_id",h).limit(50):{data:null},b=(p||[]).map(e=>({name:e.name,notes:e.notes,quantity:e.quantity_decimal,unit:e.unit,jobTitle:e.job?.title||"Unknown",customerName:e.job?.customer?.name||"Unknown"}));l={generalData:e,recentJobs:r,recentInvoices:d,customers:u,materials:b},c=`The user asked: "${s}"

Here's what I know about the business:
- Total jobs: ${e.totalJobs}
- Active jobs: ${e.activeJobs}
- Total invoiced: $${(e.totalInvoiced/100).toFixed(2)}
- Total paid: $${(e.totalPaid/100).toFixed(2)}
- Unpaid invoices: ${e.unpaidCount}

Recent jobs (last 20):
${JSON.stringify(r)}

Recent invoices (last 10):
${JSON.stringify(d)}

Customers:
${JSON.stringify(u)}

Materials (last 50):
${JSON.stringify(b)}

CRITICAL INSTRUCTIONS:
1. You must respond using ONLY the data provided above
2. Use the mandatory format:
   ðŸ“Š Answer
   ðŸ“ Data Used
   âš ï¸ Limitations
3. If you cannot answer with the provided data, say "I don't have enough data to answer that."
4. Always cite your sources (e.g., "Based on jobs data", "From invoices data")
5. Never guess, infer, or assume anything not in the data
6. If data is missing or incomplete, state it clearly in the Limitations section`}}if(u)return _.NextResponse.json({response:u});let m=["TOTAL_JOBS","TOTAL_REVENUE","JOBS_THIS_WEEK","ACTIVE_JOBS","JOBS_BY_STATUS","JOBS_TODAY","JOBS_TOMORROW","MATERIALS_TODAY","MATERIALS_TOMORROW","GENERAL_SUMMARY"].includes(r),h=l.generalData||l.recentJobs||l.recentInvoices||l.customers||l.materials;if(!m&&!h&&(void 0!==l.count&&0===l.count||l.jobs&&0===l.jobs.length||l.materials&&0===l.materials.length||l.payments&&0===l.payments.length))return _.NextResponse.json({response:"I don't see any data for that right now."});let p=process.env.OPENAI_API_KEY;if(!p)return _.NextResponse.json({response:"I can help answer questions about your jobs, invoices, and materials."});let b=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${p}`},body:JSON.stringify({model:"gpt-4o-mini",messages:[{role:"system",content:q},{role:"user",content:c}],max_tokens:400,temperature:.1})});if(!b.ok)return console.error("OpenAI API error:",await b.text()),_.NextResponse.json({response:"I'm having trouble right now. Please try again."});let w=await b.json(),y=w.choices[0]?.message?.content||"I don't have an answer for that.";return _.NextResponse.json({response:y})}catch(e){return console.error("Matte API error:",e),_.NextResponse.json({response:"I'm having trouble right now. Please try again."},{status:500})}}e.s(["POST",()=>L],28267);var M=e.i(28267);let P=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/matte/route",pathname:"/api/matte",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/apps/matte/src/app/api/matte/route.ts",nextConfigOutput:"",userland:M}),{workAsyncStorage:H,workUnitAsyncStorage:F,serverHooks:Y}=P;function B(){return(0,o.patchFetch)({workAsyncStorage:H,workUnitAsyncStorage:F})}async function K(e,t,o){P.isDev&&(0,s.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let _="/api/matte/route";_=_.replace(/\/index$/,"")||"/";let f=await P.prepare(e,t,{srcPage:_,multiZoneDraftMode:!1});if(!f)return t.statusCode=400,t.end("Bad Request"),null==o.waitUntil||o.waitUntil.call(o,Promise.resolve()),null;let{buildId:g,params:j,nextConfig:v,parsedUrl:T,isDraftMode:O,prerenderManifest:k,routerServerContext:R,isOnDemandRevalidate:S,revalidateOnlyGenerated:I,resolvedPathname:A,clientReferenceManifest:E,serverActionsManifest:N}=f,$=(0,r.normalizeAppPath)(_),C=!!(k.dynamicRoutes[$]||k.routes[A]),D=async()=>((null==R?void 0:R.render404)?await R.render404(e,t,T,!1):t.end("This page could not be found"),null);if(C&&!O){let e=!!k.routes[A],t=k.dynamicRoutes[$];if(t&&!1===t.fallback&&!e){if(v.experimental.adapterPath)return await D();throw new w.NoFallbackError}}let U=null;!C||P.isDev||O||(U="/index"===(U=A)?"/":U);let J=!0===P.isDev||!C,x=C&&!J;N&&E&&(0,i.setManifestsSingleton)({page:_,clientReferenceManifest:E,serverActionsManifest:N});let q=e.method||"GET",L=(0,n.getTracer)(),M=L.getActiveScopeSpan(),H={params:j,prerenderManifest:k,renderOpts:{experimental:{authInterrupts:!!v.experimental.authInterrupts},cacheComponents:!!v.cacheComponents,supportsDynamicResponse:J,incrementalCache:(0,s.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:v.cacheLife,waitUntil:o.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,o,s)=>P.onRequestError(e,t,o,s,R)},sharedContext:{buildId:g}},F=new d.NodeNextRequest(e),Y=new d.NodeNextResponse(t),B=l.NextRequestAdapter.fromNodeNextRequest(F,(0,l.signalFromNodeResponse)(t));try{let i=async e=>P.handle(B,H).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=L.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let o=a.get("next.route");if(o){let t=`${q} ${o}`;e.setAttributes({"next.route":o,"http.route":o,"next.span_name":t}),e.updateName(t)}else e.updateName(`${q} ${_}`)}),r=!!(0,s.getRequestMeta)(e,"minimalMode"),d=async s=>{var n,d;let l=async({previousCacheEntry:a})=>{try{if(!r&&S&&I&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await i(s);e.fetchMetrics=H.renderOpts.fetchMetrics;let d=H.renderOpts.pendingWaitUntil;d&&o.waitUntil&&(o.waitUntil(d),d=void 0);let l=H.renderOpts.collectedTags;if(!C)return await (0,m.sendResponse)(F,Y,n,H.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,h.toNodeOutgoingHttpHeaders)(n.headers);l&&(t[b.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==H.renderOpts.collectedRevalidate&&!(H.renderOpts.collectedRevalidate>=b.INFINITE_CACHE)&&H.renderOpts.collectedRevalidate,o=void 0===H.renderOpts.collectedExpire||H.renderOpts.collectedExpire>=b.INFINITE_CACHE?void 0:H.renderOpts.collectedExpire;return{value:{kind:y.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:o}}}}catch(t){throw(null==a?void 0:a.isStale)&&await P.onRequestError(e,t,{routerKind:"App Router",routePath:_,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:x,isOnDemandRevalidate:S})},!1,R),t}},c=await P.handleResponse({req:e,nextConfig:v,cacheKey:U,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:k,isRoutePPREnabled:!1,isOnDemandRevalidate:S,revalidateOnlyGenerated:I,responseGenerator:l,waitUntil:o.waitUntil,isMinimalMode:r});if(!C)return null;if((null==c||null==(n=c.value)?void 0:n.kind)!==y.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(d=c.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});r||t.setHeader("x-nextjs-cache",S?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),O&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let w=(0,h.fromNodeOutgoingHttpHeaders)(c.value.headers);return r&&C||w.delete(b.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||w.get("Cache-Control")||w.set("Cache-Control",(0,p.getCacheControlHeader)(c.cacheControl)),await (0,m.sendResponse)(F,Y,new Response(c.value.body,{headers:w,status:c.value.status||200})),null};M?await d(M):await L.withPropagatedContext(e.headers,()=>L.trace(c.BaseServerSpan.handleRequest,{spanName:`${q} ${_}`,kind:n.SpanKind.SERVER,attributes:{"http.method":q,"http.target":e.url}},d))}catch(t){if(t instanceof w.NoFallbackError||await P.onRequestError(e,t,{routerKind:"App Router",routePath:$,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:x,isOnDemandRevalidate:S})},!1,R),C)throw t;return await (0,m.sendResponse)(F,Y,new Response(null,{status:500})),null}}e.s(["handler",()=>K,"patchFetch",()=>B,"routeModule",()=>P,"serverHooks",()=>Y,"workAsyncStorage",()=>H,"workUnitAsyncStorage",()=>F],91527)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_8f41e8ae.js.map